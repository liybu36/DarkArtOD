////////////////////////////////////////////////////////////////////////
// Class:       ClusterEvaluator
// Module Type: producer
// File:        ClusterEvaluator_module.cc
//
// Generated at Thu Feb  5 10:44:16 2015 by Shawn Westerdale using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include <iostream>

//Submodules
#include "darkart/ODReco/Submodules/ClusterShapeEvaluator.hh"
#include "darkart/ODReco/Submodules/ClusterPMTDistributionEvaluator.hh"

namespace darkart {
  namespace od {
    class ClusterEvaluator;
  }
}

class darkart::od::ClusterEvaluator : public art::EDProducer {
public:
  explicit ClusterEvaluator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ClusterEvaluator(ClusterEvaluator const &) = delete;
  ClusterEvaluator(ClusterEvaluator &&) = delete;
  ClusterEvaluator & operator = (ClusterEvaluator const &) = delete;
  ClusterEvaluator & operator = (ClusterEvaluator &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  int _use_shape_evaluator;
  int _use_pmt_distribution_evaluator;
  std::string _input_waveform;
  std::string _input_pulses;
  std::string _input_clusters;

  // Initialize potential evaluator submodules
  //------------------------------------------------------------------------------
  // This sumodule evaluates parameters regarding the cluster shape
  ClusterShapeEvaluator *_cluster_shape_evaluator;
  // This submodule evaluates parameters regarding PMTs contributing to a cluster
  ClusterPMTDistributionEvaluator *_cluster_pmt_distribution_evaluator;
  // Other things that are useful for this module to know about
  art::ServiceHandle<darkart::od::Utilities> _utils;
};


darkart::od::ClusterEvaluator::ClusterEvaluator(fhicl::ParameterSet const & p)
  : _use_shape_evaluator(p.get<int>("shape_evaluator",0))
  , _use_pmt_distribution_evaluator(p.get<int>("pmt_distribution_evaluator",0))
  , _input_waveform(p.get<std::string>("input_waveform","none"))
  , _input_pulses(p.get<std::string>("input_pulses","none"))
  , _input_clusters(p.get<std::string>("input_clusters","none"))
  , _cluster_shape_evaluator(nullptr)
  , _cluster_pmt_distribution_evaluator(nullptr)
{
  // Create instances of evaluator submodules to be used
  if(_use_shape_evaluator){
    _cluster_shape_evaluator = new ClusterShapeEvaluator(p.get<fhicl::ParameterSet>("shapeparams"));
    _cluster_shape_evaluator->setUtilities(_utils->getPointer());
  }
  if(_use_pmt_distribution_evaluator){
    _cluster_pmt_distribution_evaluator = new ClusterPMTDistributionEvaluator(p.get<fhicl::ParameterSet>("pmtdistparams"));
    _cluster_shape_evaluator->setUtilities(_utils->getPointer());
  }

  // Check that input sources have been set
  if(_input_waveform == "none")
    throw cet::exception("ClusterEvaluator") << "Must specify input waveform\n";
  if(_input_pulses == "none")
    throw cet::exception("ClusterEvaluator") << "Must specify input pulses\n";
  if(_input_clusters == "none")
    throw cet::exception("ClusterEvaluator") << "Must specify input clusters\n";

  produces<darkart::od::ClusterVec>();
}

void darkart::od::ClusterEvaluator::produce(art::Event & e)
{
  // Clusters found by ClusterFinder
  auto const & raw_cluster_vec = e.getValidHandle<darkart::od::ClusterVec>(_input_clusters);
  
  // Get the pulse objects and the sum waveform for use in analyses
  auto const & channel_data_vec = e.getValidHandle<darkart::od::ChannelDataVec>(_input_pulses);
  auto const & channel_wfs_vec = e.getValidHandle<darkart::od::ChannelWFsVec>(_input_pulses);
  auto const & sum_wf = e.getValidHandle<darkart::od::SumWF>(_input_waveform);

  // This is the cluster vector that will be evaluated. Start by copying raw clusters into it
  std::unique_ptr<darkart::od::ClusterVec> evaluated_cluster_vec(new darkart::od::ClusterVec(*raw_cluster_vec));

  // Loop over all clusters and apply initialized evaluators to each
  const size_t num_clusters = evaluated_cluster_vec->size();
  for(size_t cl_idx = 0; cl_idx < num_clusters; cl_idx++){
    if(_cluster_shape_evaluator){
      _cluster_shape_evaluator->eval(*sum_wf, *evaluated_cluster_vec, cl_idx);
    }
    if(_cluster_pmt_distribution_evaluator)
      _cluster_pmt_distribution_evaluator->eval(*channel_data_vec, *channel_wfs_vec, *evaluated_cluster_vec, cl_idx);
  }

  // Insert the products into the ART event
  e.put(std::move(evaluated_cluster_vec));
}

DEFINE_ART_MODULE(darkart::od::ClusterEvaluator)
