////////////////////////////////////////////////////////////////////////
// Class:       PeHitMaker
// Module Type: producer
// File:        PeHitMaker_module.cc
//
// Generated at Tue Oct 21 23:35:44 2014 by Alden Fan using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <string>
#include <iostream>

#include "TRandom3.h"

#include "darkart/Products/PeHit.hh"
#include "darkart/TpcMC/PeTimeGenerator.hh"

namespace darkart {
  namespace MC {
    class PeHitMaker;
  }
}

////////////////////////////////////////////////////////////////////////
// 2014-10-20 AFan
//
// This is a modularization of the existing electronics MC.
// 
// Generate hits (photoelectrons) on PMTs. We generate a series of 
// PhotoElectron objects, each recording a PMT on which it occurred
// and a time at which it occurred. 
// 
// The number distribution of PE and time profile can be specified 
// somewhat independently. Modes for each are chosen at run time.
////////////////////////////////////////////////////////////////////////

class darkart::MC::PeHitMaker : public art::EDProducer {
public:
  explicit PeHitMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PeHitMaker(PeHitMaker const &) = delete;
  PeHitMaker(PeHitMaker &&) = delete;
  PeHitMaker & operator = (PeHitMaker const &) = delete;
  PeHitMaker & operator = (PeHitMaker &&) = delete;

  // Required functions.
  void beginJob() override;
  void produce(art::Event & e) override;


private:

  int _nchannels;

  // Random number generator parameters
  TRandom3* _ran;
  int _seed;

  std::string _signal_type;
  darkart::MC::PeTimeGenerator _ptg;

  double _signal_delay; //ns
  
  int _mode;

  // Fixed number of PE per channel
  struct Mode0 {
    Mode0(double n) : npe(n) {}
    double npe;
    MC::PeHitVec make_pe(TRandom3* ran, int nchannels, PeTimeGenerator ptg);
  } _mode0;


  // Poisson distributed number of PE per channel
  struct Mode1 {
    Mode1(double m) : mean(m) {}
    double mean;
    MC::PeHitVec make_pe(TRandom3* ran, int nchannels, PeTimeGenerator ptg);
  } _mode1;


  // Uniform number distribution of PE, uniformly distributed over channels
  struct Mode2 {
    Mode2(double m, double n) : min(m), max(n) {}
    double min;
    double max;
    MC::PeHitVec make_pe(TRandom3* ran, int nchannels, PeTimeGenerator ptg);
  } _mode2;


};


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
using namespace darkart;


MC::PeHitMaker::PeHitMaker(fhicl::ParameterSet const & p)
  : _nchannels(p.get<int>("nchannels"))
  , _ran(nullptr)
  , _seed(p.get<int>("seed"))
  , _signal_type(p.get<std::string>("signalType"))
  , _ptg(p.get<fhicl::ParameterSet>("signalParams"), _signal_type)
  , _signal_delay(p.get<double>("signalDelay")*1000)
  , _mode(p.get<int>("mode"))
  , _mode0(p.get<double>("mode0.npe"))
  , _mode1(p.get<double>("mode1.mean"))
  , _mode2(p.get<double>("mode2.min"), p.get<double>("mode2.max"))
{
  produces<MC::PeHitVec>();
}

//-----------------------------------------------------------------------------
void MC::PeHitMaker::beginJob()
{
  _ran = new TRandom3(_seed);
}


//-----------------------------------------------------------------------------
void MC::PeHitMaker::produce(art::Event & e)
{
  std::unique_ptr<MC::PeHitVec> peVec(new MC::PeHitVec);

  if (_mode == 0)
    *peVec = _mode0.make_pe(_ran, _nchannels, _ptg);
  if (_mode == 1)
    *peVec = _mode1.make_pe(_ran, _nchannels, _ptg);
  if (_mode == 2)
    *peVec = _mode2.make_pe(_ran, _nchannels, _ptg);

  for (auto & pe : *peVec)
    pe.time += _signal_delay;

  e.put(std::move(peVec));
}


//-----------------------------------------------------------------------------
// MODE 0
MC::PeHitVec MC::PeHitMaker::Mode0::make_pe(TRandom3* ran, 
					  int nchannels, 
					  MC::PeTimeGenerator ptg)
{
  MC::PeHitVec peVec;
  for (int i=0; i<nchannels; ++i)
    {
      for (int y=0; y<npe; ++y)
	{
	  MC::PeHit myPe;
	  myPe.pmt = i;
	  myPe.time = ptg.fire(ran);
	  peVec.push_back(std::move(myPe));
	}
    }
  return std::move(peVec);
}

//-----------------------------------------------------------------------------
// MODE 1
MC::PeHitVec MC::PeHitMaker::Mode1::make_pe(TRandom3* ran,
					  int nchannels,
					  MC::PeTimeGenerator ptg)
{
  MC::PeHitVec peVec;
  for (int i=0; i<nchannels; ++i)
    {
      int npe = ran->Poisson(mean);
      for (int y=0; y<npe; ++y)
	{
	  MC::PeHit myPe;
	  myPe.pmt = i;
	  myPe.time = ptg.fire(ran);
	  peVec.push_back(std::move(myPe));
	}
    }
  return std::move(peVec);
}


//-----------------------------------------------------------------------------
// MODE 2
MC::PeHitVec MC::PeHitMaker::Mode2::make_pe(TRandom3* ran,
					  int nchannels,
					  MC::PeTimeGenerator ptg)
{
  MC::PeHitVec peVec;

  int npe = ran->Integer(max-min+1)+min;

  for (int i=0; i<npe; ++i)
    {
      MC::PeHit myPe;
      int ch = ran->Integer(nchannels);
      myPe.pmt = ch;
      myPe.time = ptg.fire(ran);
      peVec.push_back(std::move(myPe));
    }
  return std::move(peVec);
}


DEFINE_ART_MODULE(darkart::MC::PeHitMaker)
