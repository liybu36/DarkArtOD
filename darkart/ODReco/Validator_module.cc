////////////////////////////////////////////////////////////////////////
// Class:       Validator
// Module Type: analyzer
// File:        Validator_module.cc
//
// Generated at Sat Mar 14 00:14:24 2015 by Alden Fan using artmod
// from cetpkgsupport v1_08_04.
// Completed by Laura Marini... ongoing
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include <memory>
#include <sstream>
#include <iomanip>
#include <algorithm>

#include "darkart/ODProducts/ODEventData.hh"
#include "darkart/ODProducts/RunInfo.hh"
#include "darkart/ODProducts/ODEventInfo.hh"
#include "darkart/ODProducts/ChannelData.hh"
#include "darkart/ODProducts/Cluster.hh"
#include "darkart/ODReco/Tools/Utilities.hh"

#include "TROOT.h"
#include "TColor.h"
#include "TList.h"
#include "TFile.h"
#include "TObject.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TF1.h"
#include "TGraphErrors.h"
#include "TMath.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TString.h"
#include "TStyle.h"
#include "TPDF.h"

namespace darkart {
  namespace od {
    class Validator;
  }
}

////////////////////////////////////////////////////////////////////////
// This module builds histograms that will be used to validate darkartOD
// against odrec.
// 
// We access data products using plain art::Handle (rather than
// art::ValidHandle) to better deal with modules being turned off.
////////////////////////////////////////////////////////////////////////

class darkart::od::Validator : public art::EDAnalyzer {
public:
  explicit Validator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Validator(Validator const &) = delete;
  Validator(Validator &&) = delete;
  Validator & operator = (Validator const &) = delete;
  Validator & operator = (Validator &&) = delete;

  // Required functions.
  void beginJob() override;
  void analyze(art::Event const & e) override;
  void endJob() override;

private:

  std::string _run_info_tag;
  std::string _event_info_tag;
  std::string _channel_data_tag;
  std::string _cluster_lsv_tag;
  std::string _cluster_wt_tag;

  art::ServiceHandle<darkart::od::Utilities> _utils;

  art::ServiceHandle<art::TFileService> _tfs;

  bool _first_event; 
  const int _nodchannels;
  const int _i_lsv_bins;
  const int _f_lsv_bins;
  int   _run_id;
  int   _num_events;
  int   _bad_events;
  int   _counts_low_mult_pass;
  int   _counts_low_mult_fail;
  float _lsv_ene_above;
  float _prompt_offset_ns;
  float _pre_prompt_ns;
  float _post_prompt_ns;
  float _late_cut_ns;
  float _co60_guess_peak;
  float _spe_rel_rms; // the relative SPE RMS
  bool  _plot_rates;
  bool  _save_pdf;
  std::vector<double> _pedestal_ch_mean_sum;
  std::vector<double> _pedestal_ch_rms_sum;
  std::vector<double> _charge_ch_mean_sum;
  std::vector<double> _charge_ch_rms_sum;
  std::vector<int>    _npulses_sum;
  std::vector<int>    _dscolors;
  std::vector<double> _channels_num;
  std::vector<double> _channel_id_error; // a vector of 0s, since we know channel IDs

  bool multiplicityCut(float height, float multiplicity, float charge);
  void set_style();

  // Histograms that we'll instantiate and fill
  TH1F* _h_dt_usec;
  TH1F* _h_bad_time;
  TH1F* _h_lsv_rates;
  TH1F* _h_wt_rates;
  TH1F* _h_lsv_current;
  TH1F* _h_wt_current;
  TH1F* _h_lsv_nclust;
  TH1F* _h_wt_nclust;
  TH1F* _h_lsv_spectrum;	
  TH1F* _h_wt_spectrum;	
  TH1F* _h_lsv_spectrum_low;
  TH1F* _h_lsv_spectrum_low_mult_pass;
  TH1F* _h_lsv_spectrum_low_mult_fail;
  TH1F* _h_lsv_spectrum_high;
  TH1F* _h_lsv_spectrum_coinc;
  TH1F* _h_lsv_cluster_start_ns;
  TH1F* _h_lsv_cluster_high_start_ns;
  TH1F* _h_lsv_trigger_time_ns;
  TH1F* _h_lsv_cum_late;
  TH1F* _h_lsv_spectrum_late;
  TH1F* _h_odval_summary;

  TGraphErrors* _g_lsv_pedestal_mean;
  TGraphErrors* _g_wt_pedestal_mean;
  TGraphErrors* _g_lsv_pulse_charge_mean;
  TGraphErrors* _g_wt_pulse_charge_mean;

  TCanvas* _canv_events;
  TCanvas* _canv_spectrum;
  TCanvas* _canv_spectrum_low;
  TCanvas* _canv_spectrum_high;
  TCanvas* _canv_pedestal;
  TCanvas* _canv_pulse_charge;
  TCanvas* _canv_time;
  TCanvas* _canv_current;
  TCanvas* _canv_rates;
  TCanvas* _canv_ncluster;
  TCanvas* _canv_cumulative;

  TStyle* _od_val_style;
};


darkart::od::Validator::Validator(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _run_info_tag     (p.get<std::string>( "run_info_tag"     ))
  , _event_info_tag   (p.get<std::string>( "event_info_tag"   ))
  , _channel_data_tag (p.get<std::string>( "channel_data_tag" ))
  , _cluster_lsv_tag  (p.get<std::string>( "cluster_lsv_tag"  ))
  , _cluster_wt_tag   (p.get<std::string>( "cluster_wt_tag"   ))
  , _tfs()
  , _first_event(true)
  , _nodchannels(256)
  , _i_lsv_bins(2000)
  , _f_lsv_bins(2000.)
  , _num_events(0)
  , _bad_events(0)
  , _counts_low_mult_pass(0)
  , _counts_low_mult_fail(0)
  , _lsv_ene_above    (p.get<float>       ("lsv_ene_above",   250.))
  , _pre_prompt_ns    (p.get<float>       ("pre_prompt_ns",   -100.))
  , _post_prompt_ns   (p.get<float>       ("post_prompt_ns",  -300.))
  , _late_cut_ns      (p.get<float>       ("late_cut_ns",     25000.))
  , _co60_guess_peak  (p.get<float>       ("co60_guess_peak", 600.))
  , _spe_rel_rms      (p.get<float>       ("spe_rel_rms",     0.14))
  , _plot_rates       (p.get<bool>        ("plot_rates",      true)) 
  , _save_pdf         (p.get<bool>        ("save_pdf",        true)) 
  , _od_val_style(nullptr)
{}


void darkart::od::Validator::beginJob()
{

  set_style();

  // Set the prompt offset
  _prompt_offset_ns = _utils->getPromptOffsetNs();

  // Instantiate histograms that we want to fill
  TString title_low_spectrum, title_high_spectrum, title_spectrum_coinc;
  title_low_spectrum.Form("LSV Energy Spectrum below %.0f PEs; lsv_cluster_charge [PE]; rate [Hz] / 1 PE", _lsv_ene_above );
  title_high_spectrum.Form("LSV Energy Spectrum above %.0f PEs; lsv_cluster_charge [PE]; rate [Hz] / 1 PE", _lsv_ene_above );
  title_spectrum_coinc.Form("LSV Prompt Coincidence Energy Spectrum ([%.0f, %.0f] ns); lsv_cluster_charge [PE]; counts / event / 1 PE", _pre_prompt_ns+_prompt_offset_ns, _post_prompt_ns+_prompt_offset_ns);
  
  // Digitizer timing checks
  _h_dt_usec                   = _tfs->make<TH1F> ("h_dt_usec", "; dt [#mus]", 1000, 0, 1e6);
  _h_bad_time                  = _tfs->make<TH1F> ("h_bad_time", "Events with good time alignment; bad_time_alignment (0 = good, 1 = bad); Fraction of events (%)", 2, 0., 2.);

  // Channel Diagnostics
  // Initialize vectors
  _pedestal_ch_mean_sum.assign(_nodchannels, 0.);
  _pedestal_ch_rms_sum.assign (_nodchannels, 0.);
  _charge_ch_mean_sum.assign  (_nodchannels, 0.);
  _charge_ch_rms_sum.assign   (_nodchannels, 0.);
  _channels_num.assign        (_nodchannels, 0.); 
  _channel_id_error.assign    (_nodchannels, 0.);
  // Create and name TGraphErrors
  // pedestal means
  _g_lsv_pedestal_mean    = _tfs->make<TGraphErrors>(_nodchannels);
  _g_lsv_pedestal_mean->SetName("_g_lsv_pedestal_mean");
  _g_lsv_pedestal_mean->SetTitle("Pedestal Mean and RMS on Each Channel; channel id; pedestal offset [V]");
  _g_wt_pedestal_mean    = _tfs->make<TGraphErrors>(_nodchannels);
  _g_wt_pedestal_mean->SetName("_g_wt_pedestal_mean");  
  _g_wt_pedestal_mean->SetTitle("Pedestal Mean and RMS on Each Channel; channel id; pedestal offset [V]");
  _g_lsv_pulse_charge_mean= _tfs->make<TGraphErrors>(_nodchannels);
  _g_lsv_pulse_charge_mean->SetName("_g_lsv_pulse_charge_mean");
  _g_lsv_pulse_charge_mean->SetTitle("Average Pulse Charge in Each Channel; channel id; Average Pulse Charge [V*s]");
  _g_wt_pulse_charge_mean= _tfs->make<TGraphErrors>(_nodchannels);
  _g_wt_pulse_charge_mean->SetName("_g_wt_pulse_charge_mean");
  _g_wt_pulse_charge_mean->SetTitle("Average Pulse Charge in Each Channel; channel id; Average Pulse Charge [V*s]");
  // Set marker styles
  _g_lsv_pedestal_mean->SetMarkerStyle(21);
  _g_wt_pedestal_mean->SetMarkerStyle(21);
  _g_lsv_pulse_charge_mean->SetMarkerStyle(21);
  _g_wt_pulse_charge_mean->SetMarkerStyle(21);

  

  // LSV and WT rates
  // Pulse rates
  _h_lsv_rates                 = _tfs->make<TH1F> ("h_lsv_rates", "PMT rates in LSV; channel id; Rate [Hz]", _nodchannels, 0., _nodchannels);
  _h_wt_rates                  = _tfs->make<TH1F> ("h_wt_rates",  "PMT rates in WT; channel id; Rate [Hz]",  _nodchannels, 0., _nodchannels);
  // Time-averaged charge in channels
  _h_lsv_current               = _tfs->make<TH1F> ("h_lsv_current", "PMT current in LSV; channel id; Charge current [PE/s]", _nodchannels, 0., _nodchannels);
  _h_wt_current                = _tfs->make<TH1F> ("h_wt_current", "PMT current in WT; channel id; Charge current [PE/s]", _nodchannels, 0., _nodchannels);
  // Number of clusters identified per trigger
  _h_lsv_nclust                = _tfs->make<TH1F> ("h_lsv_nclust", "Number of Clusters in LSV per trigger; lsv_n_clusters/trigger; Entries / livetime [s^{-1}]", 60, 0., 60);
  _h_wt_nclust                 = _tfs->make<TH1F> ("h_wt_nclust", "Number of Clusters in WT per trigger; wt_n_clusters/trigger; Entries / livetime [s^{-1}]", 60, 0., 60); 

  // Energy spectra
  // Full energy specta
  _h_lsv_spectrum              = _tfs->make<TH1F> ("h_lsv_spectrum","LSV Energy Spectrum; lsv_cluster_charge [PE]; Rate [Hz] / 1 PE", _i_lsv_bins, 0., _f_lsv_bins);
  _h_wt_spectrum               = _tfs->make<TH1F> ("h_wt_spectrum","WT Energy Spectrum; wt_cluster_charge [PE]; Rate [Hz] / 1 PE", _i_lsv_bins, 0., _f_lsv_bins);
  // Spectra at low energies, comparing effects of multiplicity cut
  _h_lsv_spectrum_low          = _tfs->make<TH1F> ("h_lsv_spectrum_low", title_low_spectrum, int(_lsv_ene_above), 0., _lsv_ene_above);
  _h_lsv_spectrum_low_mult_pass= _tfs->make<TH1F> ("h_lsv_spectrum_low_mult_pass", title_low_spectrum, int(_lsv_ene_above), 0., _lsv_ene_above);
  _h_lsv_spectrum_low_mult_fail= _tfs->make<TH1F> ("h_lsv_spectrum_low_mult_fail", title_low_spectrum, int(_lsv_ene_above), 0., _lsv_ene_above);
  // Spectra at high energies
  _h_lsv_spectrum_high         = _tfs->make<TH1F> ("h_lsv_spectrum_high", title_high_spectrum, _i_lsv_bins - int(_lsv_ene_above), _lsv_ene_above, _f_lsv_bins);
  // LSV prompt coincidence spectrum
  _h_lsv_spectrum_coinc        = _tfs->make<TH1F> ("h_lsv_spectrum_coinc", title_spectrum_coinc, _i_lsv_bins, 0, _f_lsv_bins);
  _h_lsv_cluster_start_ns      = _tfs->make<TH1F> ("h_lsv_cluster_start_ns","LSV Cluster start time distribution; cluster start time [ns]; Events ", 1, 0., 1.); // bin setting changed later
  _h_lsv_cluster_high_start_ns = _tfs->make<TH1F> ("h_lsv_cluster_high_start_ns","LSV High Enerrgy Cluster start time distribution; cluster start time [ns]; Events ", 1, 0., 1.); // bin setting changed later
  _h_lsv_trigger_time_ns       = _tfs->make<TH1F> ("h_lsv_trigger_time_ns","Trigger time; cluster start time [ns]; Events ", 1, 0., 1.); // bin setting changed later
  _h_lsv_cum_late              = _tfs->make<TH1F> ("h_lsv_cum_late", "LSV cumulative activity vs threshold; lsv_cluster_charge [PE]; Activity [Hz]", _i_lsv_bins, 0., _f_lsv_bins);
  _h_lsv_spectrum_late         = _tfs->make<TH1F> ("h_lsv_spectrum_late","LSV Energy Spectrum Late; lsv_cluster_charge [PE]; Rate [Hz] / 1 PE", _i_lsv_bins, 0, _f_lsv_bins);

  // This histogram stores special values calculated by this macro for future use
  _h_odval_summary             = _tfs->make<TH1F> ("h_odval_summary","OD Validation Summary; bin 0 -> LSV Low Rate (Hz), bin 1 -> LSV Low Rate mult fail (Hz), bin 2 -> LSV Low Rate mult pass (Hz), bin 11 -> Co60 mean (PE), bin 12 -> Co60 sigma (PE), bin 13 -> Co60 LY (PE/keV), bin 20 -> TPC prompt time (ns), bin 21 -> TPC prompt sigma (ns)", 30, 0, 30.);

  // Istantiate canvases
  _canv_events         = _tfs->make<TCanvas>("canv_events",         "OD Events");
  _canv_spectrum       = _tfs->make<TCanvas>("canv_spectrum",       "LSV Spectrum");
  _canv_spectrum_low   = _tfs->make<TCanvas>("canv_low",            "LSV Low Spectrum");
  _canv_spectrum_high  = _tfs->make<TCanvas>("canv_high",           "LSV High Spectrum");
  _canv_pedestal       = _tfs->make<TCanvas>("canv_pedestal",       "OD Pedestal mean");
  _canv_pulse_charge   = _tfs->make<TCanvas>("canv_pulse_charge",   "OD Pulse charge means");
  _canv_time           = _tfs->make<TCanvas>("canv_time",           "LSV start time");
  _canv_current        = _tfs->make<TCanvas>("canv_current",        "OD PMT Currents");
  _canv_rates          = _tfs->make<TCanvas>("canv_rates",          "OD PMT Rates");
  _canv_ncluster       = _tfs->make<TCanvas>("canv_ncluster",       "OD Cluster number");
  _canv_cumulative     = _tfs->make<TCanvas>("canv_cumulative",     "LSV cumulative activity vs threshold");

  _num_events = 0;
  _bad_events = 0;
  _npulses_sum.assign (_nodchannels, 1.);  // assigned to 1 to avoid division by zero later

}

void darkart::od::Validator::endJob()
{
  // Finalize histograms
 
  if (_num_events == 0){ 
    _num_events = 1; // avoid division by zero - in any case if _num_events == 0 there is a problem
    //warning message ... I'm not sure this is the right way to throw a message. What is the difference between this and LOG_INFO ??????
    throw cet::exception("Validator") << "WARNING: run "<< _run_id <<" has no events!";
  }

  // ASSERT: the rate and gate for LSV and WT is equal; if not, add separate lines for LSV and WT
  // Fill vectors and then the TGraph for the pedestal mean and sigma. 
  // The sigma is shown as the error bars of the means.
  for(int ch_idx=0; ch_idx < _nodchannels; ch_idx++){
    // Calculate averages for channel diagnostic variables
    _pedestal_ch_mean_sum[ch_idx] /= _npulses_sum[ch_idx];
    _pedestal_ch_rms_sum[ch_idx]  /= _npulses_sum[ch_idx];
    _charge_ch_mean_sum[ch_idx]   /= _npulses_sum[ch_idx];
    _charge_ch_rms_sum[ch_idx]    = sqrt(_charge_ch_rms_sum[ch_idx]/_npulses_sum[ch_idx] + 
					 _charge_ch_mean_sum[ch_idx]*_charge_ch_mean_sum[ch_idx]);
    // Add channels' points to the TGraphErrors
    if(_utils->getChannelType(ch_idx) == 1){
      if(_pedestal_ch_mean_sum[ch_idx] != 0 || ch_idx == 0 || ch_idx == _nodchannels){
	_g_lsv_pedestal_mean->SetPoint(ch_idx, ch_idx, _pedestal_ch_mean_sum[ch_idx]);
	_g_lsv_pedestal_mean->SetPointError(ch_idx, 0, _pedestal_ch_rms_sum[ch_idx]);
      }
      if(_charge_ch_mean_sum[ch_idx] != 0 || ch_idx == 0 || ch_idx == _nodchannels){
	_g_lsv_pulse_charge_mean->SetPoint(ch_idx, ch_idx, _charge_ch_mean_sum[ch_idx]);
	_g_lsv_pulse_charge_mean->SetPointError(ch_idx, 0, _charge_ch_rms_sum[ch_idx]);
      }
    }
    else if(_utils->getChannelType(ch_idx) == 2){
      if(_pedestal_ch_mean_sum[ch_idx] != 0 || ch_idx == 0 || ch_idx == _nodchannels){
	_g_wt_pedestal_mean->SetPoint(ch_idx, ch_idx, _pedestal_ch_mean_sum[ch_idx]);
	_g_wt_pedestal_mean->SetPointError(ch_idx, 0, _pedestal_ch_rms_sum[ch_idx]);
      }
      if(_charge_ch_mean_sum[ch_idx] != 0 || ch_idx == 0 || ch_idx == _nodchannels){
	_g_wt_pulse_charge_mean->SetPoint(ch_idx, ch_idx, _charge_ch_mean_sum[ch_idx]);
	_g_wt_pulse_charge_mean->SetPointError(ch_idx, 0, _charge_ch_rms_sum[ch_idx]);
      }
    }
  }

  //Here scale all the histogram for the total livetime so that all hist are normalized
  const double sample_rate_Hz = _utils->getLSVSampleRateHz();
  const double sample_rate_GHz = _utils->getLSVSampleRateGHz();
  const double gate_s  = double(_utils->getLSVRecordLength())/sample_rate_Hz;
  const double gate_ns = double(_utils->getLSVRecordLength())/sample_rate_GHz;
  const double odtime      = ( _num_events - _bad_events ) * gate_s;
  const double odtime_late = ( _num_events - _bad_events ) * ((gate_ns - _late_cut_ns)*1.e-9);
  const double ref_pos =  double(_utils->getLSVReferencePos());

  const Float_t counts_low_mult_pass_unc = TMath::Sqrt(_counts_low_mult_pass);
  const Float_t counts_low_mult_fail_unc = TMath::Sqrt(_counts_low_mult_fail);
  const Float_t rate_low_mult_pass = _counts_low_mult_pass / odtime;
  const Float_t rate_low_mult_pass_unc = counts_low_mult_pass_unc / odtime;
  const Float_t rate_low_mult_fail = _counts_low_mult_fail / odtime;
  const Float_t rate_low_mult_fail_unc = counts_low_mult_fail_unc / odtime;

  const Float_t counts_high      = _h_lsv_spectrum_high->Integral();
  const Float_t counts_high_unc  = TMath::Sqrt(counts_high);
  const Float_t rate_high      = counts_high / odtime;
  const Float_t rate_high_unc  = counts_high_unc / odtime;

  _h_bad_time    ->Scale(1./_num_events*100.);
  _h_lsv_rates   ->Scale(1./odtime);  //rates are in Hz
  _h_wt_rates    ->Scale(1./odtime);  //rates are in Hz
  _h_lsv_current ->Scale(1./odtime);  //currents are in PE/s
  _h_wt_current  ->Scale(1./odtime);  //currents are in PE/s
  _h_lsv_spectrum->Scale(1./odtime);  //spectrum is in Hz/1PE
  _h_wt_spectrum ->Scale(1./odtime);  //spectrum is in Hz/1PE
  _h_lsv_nclust  ->Scale(1./odtime);  //n cluster spectrum is in 1/s
  _h_wt_nclust   ->Scale(1./odtime);  //n cluster spectrum is in 1/s
  _h_lsv_spectrum              ->Scale(1./odtime); //spectrum is in Hz/1PE
  _h_lsv_spectrum_low          ->Scale(1./odtime); //spectrum is in Hz/1PE
  _h_lsv_spectrum_low_mult_pass->Scale(1./odtime); //spectrum is in Hz/1PE
  _h_lsv_spectrum_low_mult_fail->Scale(1./odtime); //spectrum is in Hz/1PE
  _h_lsv_spectrum_high         ->Scale(1./(4.*odtime)); //spectrum is in Hz/4PE
  _h_lsv_spectrum_high         ->Rebin(4); //spectrum is in Hz/1PE
  _h_lsv_spectrum_coinc        ->Sumw2();
  _h_lsv_spectrum_coinc        ->Scale(1./(1.*_num_events)); //spectrum is in counts/event
  _h_lsv_spectrum_coinc        ->Rebin(1); //spectrum is in Hz/1PE

  // LSV activity cumulative
        
  for (int i=0;i <_i_lsv_bins; i++){
	  const Float_t cum = _h_lsv_spectrum_late->Integral(i, _i_lsv_bins);
	  _h_lsv_cum_late->SetBinContent(i, cum);
  }
  _h_lsv_cum_late->Scale(1./odtime_late); 

  // Co60 Fit
  std::cout << "Fitting 60Co " << std::endl;
  const int   co60_max_bin    = _h_lsv_spectrum_coinc->GetMaximumBin();
  const float co60_guess_rate = _h_lsv_spectrum_coinc->GetBinContent(co60_max_bin);
  const float co60_start_ene  = 400.;
  const float co60_end_ene    = 1000.;
  TF1 tf1_co60("tf1_co60", "gaus(0)+expo(3)", co60_start_ene, co60_end_ene);
  tf1_co60.SetParNames  ("Co60 Ampl. [Hz]", "Mean [PE]", "sigma [PE]", "Expo Const", "Expo Slope [1/PE]");
  tf1_co60.SetParameters(co60_guess_rate,    _co60_guess_peak,       82.82,       -1.,      -3.e-3);
  tf1_co60.SetLineColor(_dscolors[6]);
  _h_lsv_spectrum_coinc->Fit(&tf1_co60, "LLRO", "", co60_start_ene, co60_end_ene);
  const float ene_co60       = 1250.; // av of 2 peaks, in keV
  const float mean_co60      = tf1_co60.GetParameter(1);
  const float mean_co60_err  = tf1_co60.GetParError(1);
  const float sigma_co60     = tf1_co60.GetParameter(2);
  const float sigma_co60_err = tf1_co60.GetParError(2);
  const float ly_co60     = mean_co60/ene_co60;
  const float ly_co60_err = mean_co60_err/ene_co60;

  // fit a gaussian to the time distribution to find the prompt offset
  const int time_dist_max_bin = _h_lsv_cluster_high_start_ns->GetMaximumBin();
  TF1 tf1_coinc_high("tf1_coinc_high", "gaus(0)+pol0(3)", -(gate_ns * ref_pos), gate_ns-(gate_ns* ref_pos));
  tf1_coinc_high.SetParNames("TPC Coinc. Ampl", "Mean [ns]", "Sigma [ns]", "Const");
  tf1_coinc_high.SetParameter(0, _h_lsv_cluster_high_start_ns->GetBinContent(time_dist_max_bin));
  tf1_coinc_high.SetParameter(1, _h_lsv_cluster_high_start_ns->GetBinCenter(time_dist_max_bin));
  tf1_coinc_high.SetParameter(2, 4);
  tf1_coinc_high.SetParameter(3, _h_lsv_cluster_high_start_ns->GetMean());

  _h_lsv_cluster_high_start_ns->Fit(&tf1_coinc_high, "LLRN", "", -(gate_ns * ref_pos), gate_ns-(gate_ns* ref_pos));
  const Float_t coinc_high_rate  = tf1_coinc_high.GetParameter(0);
  const Float_t coinc_high_const = tf1_coinc_high.GetParameter(3);
  const bool is_coinc_high       = (coinc_high_rate > 30. * coinc_high_const);
  const Float_t coinc_mean       = (is_coinc_high) ? tf1_coinc_high.GetParameter(1) : -99999.;
  const Float_t coinc_mean_err   = (is_coinc_high) ? tf1_coinc_high.GetParError(1) : 0.;
  const Float_t coinc_sigma      = (is_coinc_high) ? tf1_coinc_high.GetParameter(2): 0.;
  const Float_t coinc_sigma_err  = (is_coinc_high) ? tf1_coinc_high.GetParError(2) : 0.;

  // Colors
  _h_bad_time          ->SetLineColor(_dscolors[0]);
  _h_bad_time          ->SetFillColor(_dscolors[6]);
  _h_lsv_rates         ->SetLineColor(_dscolors[0]);
  _h_lsv_rates         ->SetFillColor(_dscolors[1]);
  _h_wt_rates          ->SetLineColor(_dscolors[0]);
  _h_wt_rates          ->SetFillColor(_dscolors[2]);
  _h_lsv_current       ->SetLineColor(_dscolors[0]);
  _h_lsv_current       ->SetFillColor(_dscolors[1]);
  _h_wt_current        ->SetLineColor(_dscolors[0]);
  _h_wt_current        ->SetFillColor(_dscolors[2]);
  _h_lsv_nclust        ->SetLineColor(_dscolors[0]);
  _h_lsv_nclust        ->SetFillColor(_dscolors[1]);
  _h_wt_nclust         ->SetLineColor(_dscolors[0]);
  _h_wt_nclust         ->SetFillColor(_dscolors[2]);
  _h_lsv_spectrum      ->SetLineColor(_dscolors[1]);
  _h_lsv_spectrum_coinc->SetLineColor(_dscolors[3]);
  _h_wt_spectrum   ->SetLineColor(_dscolors[0]);
  _h_lsv_spectrum_high         ->SetLineColor(_dscolors[0]);
  _h_lsv_spectrum_high         ->SetFillColor(_dscolors[1]);
  _h_lsv_spectrum_low          ->SetLineColor(_dscolors[0]);
  //  _h_lsv_spectrum_low          ->SetFillColor(_dscolors[9]);
  _h_lsv_spectrum_low_mult_pass->SetLineColor(_dscolors[1]);
  _h_lsv_spectrum_low_mult_fail->SetLineColor(_dscolors[6]);
  _h_lsv_cluster_start_ns      ->SetLineColor(_dscolors[0]);
  _h_lsv_cluster_start_ns      ->SetFillColor(_dscolors[5]);
  _h_lsv_trigger_time_ns       ->SetLineColor(_dscolors[4]);
  _h_lsv_cluster_high_start_ns ->SetLineColor(_dscolors[3]);
  _h_lsv_cum_late         ->SetLineColor(_dscolors[5]); 
  _g_lsv_pedestal_mean    ->SetMarkerColor(_dscolors[1]);
  _g_wt_pedestal_mean     ->SetMarkerColor(_dscolors[2]);
  _g_lsv_pulse_charge_mean->SetMarkerColor(_dscolors[1]);
  _g_wt_pulse_charge_mean ->SetMarkerColor(_dscolors[2]);

  // odval summary
  _h_odval_summary -> SetBinContent(0, rate_low_mult_fail + rate_low_mult_pass);
  _h_odval_summary -> SetBinError(1, rate_low_mult_fail_unc);
  _h_odval_summary -> SetBinContent(1, rate_low_mult_fail);
  _h_odval_summary -> SetBinError(1, rate_low_mult_fail_unc);
  _h_odval_summary -> SetBinContent(2, rate_low_mult_pass);
  _h_odval_summary -> SetBinError(2, rate_low_mult_pass_unc);
  _h_odval_summary -> SetBinContent(11, mean_co60);
  _h_odval_summary -> SetBinError(11, mean_co60_err);
  _h_odval_summary -> SetBinContent(12, sigma_co60);
  _h_odval_summary -> SetBinError(12, sigma_co60_err);
  _h_odval_summary -> SetBinContent(13, ly_co60);
  _h_odval_summary -> SetBinError(13, ly_co60_err);
  _h_odval_summary -> SetBinContent(20, coinc_mean);
  _h_odval_summary -> SetBinError(20, coinc_mean_err);
  _h_odval_summary -> SetBinContent(21, coinc_sigma);
  _h_odval_summary -> SetBinError(21, coinc_sigma_err);
  
  // Fill Canvases
  // c0: events, bad_time_alignment 
  _canv_events    ->cd();
  _h_bad_time   ->Draw("");
  TLegend leg_events(0.55, 0.9, 0.9, 0.6);
  TString string_run, string_num_events, string_num_badtime, string_odtime;
  string_run.Form("Events - Run %d", _run_id);
  string_num_events.Form("Total number of events: %d", _num_events);
  string_num_badtime.Form("Total number of bad time alignment events: %d", _bad_events);
  string_odtime.Form("Livetime: %.4f s", odtime);
  leg_events.SetHeader(string_run);
  leg_events.AddEntry((TObject*)0,string_num_events,"");
  leg_events.AddEntry((TObject*)0,string_num_badtime,"");
  leg_events.AddEntry((TObject*)0,string_odtime,"");
  leg_events.SetFillColorAlpha(kWhite,0.5);
  leg_events.SetFillStyle(1000);
  leg_events.Draw();
  _canv_events    ->Update();
  _canv_events    ->Write();

  // c1_spectrum: total spectrum
  _canv_spectrum   ->cd();
  _canv_spectrum   ->Divide(1,2);
  _canv_spectrum   ->cd(1)->SetLogy();
  std::ostringstream oss_high_coinc;
  oss_high_coinc<<"Coincidence with TPC (" 
		<< _prompt_offset_ns + _pre_prompt_ns 
		<< " to " 
		<< _prompt_offset_ns + _post_prompt_ns << " ns)";
  TString title_tot_spectrum,head_spectrum;
  title_tot_spectrum.Form("LSV Energy Spectrum; lsv_cluster_charge [PE]; Rate [Hz] / 1 PE");
  _h_lsv_spectrum->SetTitle(title_tot_spectrum);
  _h_lsv_spectrum->Draw();
  TLegend leg_canv_spectrum(0.4, 0.85, 0.95, 0.5);
  head_spectrum.Form("LSV energy spectrum - Run %d", _run_id);
  TString string_co60_fit, string_co60_ly;
  string_co60_fit.Form("Fit ^{60}Co - #mu: %.1f#pm%.1fPE - #sigma: %.1f#pm%.1fPE", mean_co60, mean_co60_err, sigma_co60, sigma_co60_err);
  string_co60_ly.Form("LY with ^{60}Co: %.1f#pm%.1fPE/keV", ly_co60, ly_co60_err);
  leg_canv_spectrum.AddEntry((TObject*)0,string_co60_fit,"");
  leg_canv_spectrum.AddEntry((TObject*)0,string_co60_ly,"");
  /*
  leg_canv_spectrum.SetHeader(head_spectrum);
  leg_canv_spectrum.AddEntry(_h_lsv_spectrum, "all clusters");
  leg_canv_spectrum.AddEntry(_h_lsv_spectrum_coinc, oss_high_coinc.str().c_str());
  leg_canv_spectrum.SetFillColorAlpha(kWhite,0.5);
  leg_canv_spectrum.SetFillStyle(1000);
  leg_canv_spectrum.Draw();
  */
  _canv_spectrum->cd(2)->SetLogy();  
  _h_lsv_spectrum_coinc->Draw();
    
  _canv_spectrum->Update();
  _canv_spectrum->Write();

  // c1_low: spectrum
  _canv_spectrum_low   ->cd();
  _canv_spectrum_low   ->SetLogy(1);
  TString title_low_spectrum;
  title_low_spectrum.Form("LSV Energy Spectrum below %.0f PEs; lsv_cluster_charge [PE]; rate [Hz] / 1 PE", _lsv_ene_above );
  _h_lsv_spectrum_low->SetTitle(title_low_spectrum);
  _h_lsv_spectrum_low->Draw();
  _h_lsv_spectrum_low_mult_pass->Draw("SAME");
  _h_lsv_spectrum_low_mult_fail->Draw("SAME");
  //  _h_lsv_spectrum_low->Draw("SAME");
  TLegend leg_canv_low(0.35, 0.85, 0.95, 0.5);
  std::ostringstream oss_low_head, oss_low_fail, oss_low_pass;
  oss_low_head<<"Low energy LSV spectrum (below " << _lsv_ene_above <<" PE) - Run "<< _run_id;
  oss_low_fail<< "failing multiplicity cut: " << std::setprecision(3) << rate_low_mult_fail << " #pm " << rate_low_mult_fail_unc << " Hz";
  oss_low_pass<< "passing multiplicity cut: " << std::setprecision(3) << rate_low_mult_pass << " #pm " << rate_low_mult_pass_unc << " Hz";
  leg_canv_low.SetHeader(oss_low_head.str().c_str());
  leg_canv_low.AddEntry(_h_lsv_spectrum_low,"all clusters","L");
  leg_canv_low.AddEntry(_h_lsv_spectrum_low_mult_fail, oss_low_fail.str().c_str(),"L");
  leg_canv_low.AddEntry(_h_lsv_spectrum_low_mult_pass, oss_low_pass.str().c_str(),"L");
  leg_canv_low.SetFillColorAlpha(kWhite,0.5);
  leg_canv_low.SetFillStyle(1000);
  leg_canv_low.Draw();
  _canv_spectrum_low->Update();
  _canv_spectrum_low->Write();

  // c1_high: spectrum
  _canv_spectrum_high   ->cd();
  _canv_spectrum_high   ->SetLogy(1);
  TString title_high_spectrum;
  title_high_spectrum.Form("LSV Energy Spectrum above %.0f PEs; lsv_cluster_charge [PE]; Rate [Hz] / 4 PE", _lsv_ene_above );
  _h_lsv_spectrum_high->SetTitle(title_high_spectrum);
  _h_lsv_spectrum_high->Draw();
  //  _h_lsv_spectrum_coinc->Draw("SAME");
  TLegend leg_canv_high(0.5, 0.9, 0.9, 0.6);
  std::ostringstream oss_high_head, oss_high;//, oss_high_coinc;
  oss_high_head<<"High energy LSV spectrum (above " << _lsv_ene_above<<" PE) - Run " << _run_id;
  oss_high<<"all clusters: "<< std::setprecision(3) << rate_high << " #pm " <<rate_high_unc << " Hz";
  /*
  oss_high_coinc<<"Coincidence with TPC (" 
		<< _prompt_offset_ns + _pre_prompt_ns 
		<< " to " 
		<< _prompt_offset_ns + _post_prompt_ns << " ns)";
  */
  leg_canv_high.SetHeader(oss_high_head.str().c_str());
  leg_canv_high.AddEntry(_h_lsv_spectrum_high, oss_high.str().c_str(), "L");
  //  leg_canv_high.AddEntry(_h_lsv_spectrum_coinc, oss_high_coinc.str().c_str(), "L");
  leg_canv_high.SetFillColorAlpha(kWhite,0.5);
  leg_canv_high.SetFillStyle(1000);
  leg_canv_high.Draw(); 
  _canv_spectrum_high->Update();
  _canv_spectrum_high->Write();

  // c2: pedestal mean
  _canv_pedestal->cd();
  _g_wt_pedestal_mean->Draw("AP");
  _g_lsv_pedestal_mean->Draw("P");
  TLegend leg_pedestal(0.5, 0.90, 0.95, 0.7);
  leg_pedestal.SetHeader("LSV and WT channel pedestal means");
  leg_pedestal.AddEntry(_g_lsv_pedestal_mean, "LSV","p");
  leg_pedestal.AddEntry(_g_wt_pedestal_mean, "WT","p");
  leg_pedestal.AddEntry((TObject*)0, "Error bar is pedestal rms","");
  leg_pedestal.SetFillColorAlpha(kWhite,0.5);
  leg_pedestal.SetFillStyle(1000);
  leg_pedestal.Draw();
  _canv_pedestal->Update();
  _canv_pedestal->Write();

  // c3: pulse charges
  _canv_pulse_charge->cd();
  TBox *spebox = new TBox(0,1-_spe_rel_rms,_nodchannels,1+_spe_rel_rms);
  spebox->SetFillColor(_dscolors[3]);
  spebox->SetLineColor(_dscolors[0]);
  spebox->SetLineWidth(0);
  spebox->SetFillStyle(3001);
  _g_wt_pulse_charge_mean->Draw("AP");
  _g_lsv_pulse_charge_mean->Draw("P");
  spebox->Draw("same");
  TLegend leg_pulse(0.5, 0.90, 0.95, 0.7);
  leg_pulse.SetHeader("LSV and WT channel mean pulse charges");
  leg_pulse.AddEntry(_g_lsv_pedestal_mean, "LSV","p");
  leg_pulse.AddEntry(_g_wt_pedestal_mean, "WT","p");
  leg_pulse.AddEntry(spebox,"Expected range of SPE means [PE]","f");
  leg_pulse.AddEntry((TObject*)0, "Error bars are pedestal rms","");
  leg_pulse.SetFillColorAlpha(kWhite,0.5);
  leg_pulse.SetFillStyle(1000);
  leg_pulse.Draw();
  _canv_pulse_charge->Update();
  _canv_pulse_charge->Write();

  // c4: time distribution
  _canv_time->cd();
  const Int_t peak_time_bin = _h_lsv_cluster_start_ns->GetMaximumBin();
  const Float_t max_time_content = _h_lsv_cluster_start_ns ->GetBinContent(peak_time_bin);
  TH1F* h_lsv_tpc_time_high = (TH1F*) _h_lsv_cluster_start_ns->Clone("h_lsv_tpc_time");
  h_lsv_tpc_time_high->Reset();
  h_lsv_tpc_time_high->SetFillStyle(3001);
  h_lsv_tpc_time_high->SetFillColor(_dscolors[4]);
  h_lsv_tpc_time_high->SetLineColor(_dscolors[4]);
  const Int_t bin_prompt_start = h_lsv_tpc_time_high->GetXaxis()->FindBin(_prompt_offset_ns+_pre_prompt_ns);
  const Int_t bin_prompt_end   = h_lsv_tpc_time_high->GetXaxis()->FindBin(_prompt_offset_ns+_post_prompt_ns);
  const Float_t coinc_high_guess_rate = _h_lsv_cluster_start_ns->GetBinContent(peak_time_bin);
  for (int i= bin_prompt_start; i<bin_prompt_end; i++){
	  h_lsv_tpc_time_high->SetBinContent(i, 1.5*coinc_high_guess_rate);
  }
  // I can't tell what these three histograms are supposed to be doing, but it doesn't look like they were working
  //  h_lsv_tpc_time_high->Draw("");
  //  _h_lsv_trigger_time_ns  ->SetBinContent(int((gate_s*1.e9*15./1000)), max_time_content);
  //  _h_lsv_trigger_time_ns  ->Draw("SAME");
  TBox *promptbox = new TBox(_prompt_offset_ns+_pre_prompt_ns, 0,
			     _prompt_offset_ns+_post_prompt_ns, max_time_content);
  promptbox->SetFillColorAlpha(_dscolors[4],0.5);
  promptbox->SetFillStyle(1000);

  //  _h_lsv_cluster_start_ns ->Draw("SAME");
  _h_lsv_cluster_start_ns ->Draw();
  _h_lsv_cluster_high_start_ns ->Draw("SAME");
  promptbox->Draw("same");
  TLegend leg_time(0.5, 0.9, 0.9, 0.6);
  std::ostringstream oss_time_head, oss_time_high, oss_time_high_coinc, oss_time_high_mean, oss_time_high_sigma;
  oss_time_head<<"LSV Cluster start times - Run "<< _run_id;
  oss_time_high_coinc<<"Expected TPC prompt (" 
		     << _prompt_offset_ns+_pre_prompt_ns 
		     << " to " 
		     << _prompt_offset_ns-_post_prompt_ns 
		     << " ns)";
  oss_time_high<<"LSV Cluster start times (above "  << _lsv_ene_above<<" PE) ";
  leg_time.SetHeader(oss_time_head.str().c_str());
  //  leg_time.AddEntry(h_lsv_tpc_time_high, oss_time_high_coinc.str().c_str());
  leg_time.AddEntry(promptbox, "Expected Prompt Region","f");
  leg_time.AddEntry(_h_lsv_cluster_start_ns, "LSV cluster start times (ns)","f");
  leg_time.AddEntry(_h_lsv_cluster_high_start_ns, oss_time_high.str().c_str(), "f");
  //  leg_time.AddEntry(_h_lsv_trigger_time_ns, "Trigger time","l");
  const std::string str_coinc_high = (is_coinc_high) ? "TPC prompt coincidence found" : "WARNING: NO TPC prompt coincidence";
  leg_time.AddEntry((TObject*)0, str_coinc_high.c_str(),"");
  if (is_coinc_high){
	  oss_time_high_mean  << " Prompt Coincidence Window mean: " << std::setprecision(4) << coinc_mean << " #pm " << std::setprecision(1) << coinc_mean_err << " ns";
	  oss_time_high_sigma << " Prompt Coincidence Window #sigma: " << std::setprecision(2) << coinc_sigma << " #pm " << coinc_sigma_err << " ns";
	  leg_time.AddEntry((TObject*)0, oss_time_high_mean.str().c_str(),"");
	  leg_time.AddEntry((TObject*)0, oss_time_high_sigma.str().c_str(),"");
  }
  leg_time.SetFillColorAlpha(kWhite,0.5);
  leg_time.SetFillStyle(1000);
  leg_time.Draw();
  _canv_time->Update();
  _canv_time->Write();

  // canv: currents
  _canv_current   ->cd();
  _h_lsv_current->SetTitle("OD PMT current; OD Channel; PMT charge current [PE/s]");  
  // find the maximum of the histos
  const Float_t max_current_lsv = _h_lsv_current ->GetBinContent(_h_lsv_current ->GetMaximumBin());
  const Float_t max_current_wt  = _h_wt_current  ->GetBinContent(_h_wt_current  ->GetMaximumBin());
  const float max_current = std::max(max_current_lsv, max_current_wt);
  _h_lsv_current->GetYaxis()->SetRangeUser(10, 1.5 * max_current);
  _h_wt_current ->GetYaxis()->SetRangeUser(10, 1.5 * max_current);
  _h_lsv_current->Draw("");
  _h_wt_current ->Draw("SAME");
  _canv_current   ->SetLogy(1);
  TLegend leg_current(0.6, 0.9, 0.9, 0.7);
  string_run.Form("OD PMT charge current -  Run %d", _run_id);
  leg_current.SetHeader(string_run);
  leg_current.AddEntry(_h_lsv_current,"PMT currents in LSV");
  leg_current.AddEntry(_h_wt_current,"PMT currents in WT");
  leg_current.SetFillColorAlpha(kWhite,0.5);
  leg_current.SetFillStyle(1000);
  leg_current.Draw();
  _canv_current   ->Update();
  _canv_current   ->Write();

  // c5: rates
  _canv_rates     ->cd();
  _h_lsv_rates  ->SetTitle("OD PMT rates; OD Channel; PMT rates [Hz]");  
  const Float_t max_rate_lsv = _h_lsv_rates ->GetBinContent(_h_lsv_rates ->GetMaximumBin());
  const Float_t max_rate_wt  = _h_wt_rates  ->GetBinContent(_h_wt_rates  ->GetMaximumBin());
  const float max_rate = std::max(max_rate_lsv, max_rate_wt);
  _h_lsv_rates  ->GetYaxis()->SetRangeUser(10, 1.5 * max_rate);
  _h_wt_rates   ->GetYaxis()->SetRangeUser(10, 1.5 * max_rate);
  _h_lsv_rates  ->Draw("");
  _h_wt_rates   ->Draw("SAME");
  _canv_rates     ->SetLogy(1);
  TLegend leg_rates(0.6, 0.9, 0.9, 0.7);
  string_run.Form("OD PMT rates -  Run %d", _run_id);
  leg_rates.SetHeader(string_run);
  leg_rates.AddEntry(_h_lsv_rates,"PMT rates in LSV");
  leg_rates.AddEntry(_h_wt_rates,"PMT rates in WT");
  leg_rates.SetFillColorAlpha(kWhite,0.5);
  leg_rates.SetFillStyle(1000);
  leg_rates.Draw();
  _canv_rates     ->Update();
  _canv_rates     ->Write();

  // c6: number of cluster
  _canv_ncluster    ->cd();
  _h_lsv_nclust  ->SetTitle("Number of OD clusters per trigger; number of clusters per trigger; Entries / livetime [s^{-1}]");
  const Float_t max_clust_lsv = _h_lsv_nclust ->GetBinContent(_h_lsv_nclust ->GetMaximumBin());
  const Float_t max_clust_wt  = _h_wt_nclust  ->GetBinContent(_h_wt_nclust  ->GetMaximumBin());
  const float max_clust = std::max(max_clust_lsv, max_clust_wt);
  _h_lsv_nclust  ->GetYaxis()->SetRangeUser(0, 1.2 * max_clust);
  _h_wt_nclust   ->GetYaxis()->SetRangeUser(0, 1.2 * max_clust);
  _h_lsv_nclust   ->Draw("");
  _h_wt_nclust    ->Draw("SAME");
  TLegend leg_nclusters(0.4, 0.85, 0.95, 0.5);
  TString string_cluster_canv_head, string_cluster_lsv, string_cluster_wt;
  string_cluster_canv_head.Form("Number of OD clusters per trigger -  Run %d - Gate %.6f ns", _run_id, gate_ns);
  string_cluster_lsv.Form("LSV num cluster/trigger: #mu=%.1f #sigma=%.1f",_h_lsv_nclust->GetMean(),_h_lsv_nclust->GetRMS());
  string_cluster_wt.Form("WT num cluster/trigger: #mu=%.1f #sigma=%.1f",_h_wt_nclust->GetMean(),_h_wt_nclust->GetRMS());
  leg_nclusters.SetHeader(string_cluster_canv_head);
  leg_nclusters.AddEntry(_h_lsv_nclust,"LSV clusters per trigger");
  leg_nclusters.AddEntry((TObject*)0,string_cluster_lsv,"");
  leg_nclusters.AddEntry(_h_wt_nclust,"WT clusters per trigger");
  leg_nclusters.AddEntry((TObject*)0,string_cluster_wt,"");
  leg_nclusters.SetFillColorAlpha(kWhite,0.5);
  leg_nclusters.SetFillStyle(1000);
  leg_nclusters.Draw();
  _canv_ncluster     ->Update();
  _canv_ncluster     ->Write();

  // cumulative activity
  _canv_cumulative->cd();
  _canv_cumulative->SetGridx(1);
  _canv_cumulative->SetGridy(1);
  _canv_cumulative->SetLogy(1);
  _h_lsv_cum_late->GetXaxis()->SetRangeUser(0, 1000.);
  _h_lsv_cum_late->Draw();
  TString string_cum_canv_head;
  string_cum_canv_head.Form("LSV cumulative activity vs threshold -  Run %d - Gate > %f.3 ns", _run_id, _late_cut_ns);
  TLegend leg_cum(0.4, 0.85, 0.95, 0.5);
  leg_cum.SetHeader(string_cum_canv_head);  
  leg_cum.SetFillColorAlpha(kWhite,0.5);
  leg_cum.SetFillStyle(1000);
  leg_cum.Draw();
  _canv_cumulative->Update();
  _canv_cumulative->Write();

  // save all TCanvavs as a unique .pdf file
  TString validation_pdf;
  validation_pdf.Form("OD_validation_Run%d.pdf",_run_id);
  if (_save_pdf){
    _canv_events          ->Print(validation_pdf+"(");
    _canv_spectrum_low    ->Print(validation_pdf);
    _canv_spectrum_high   ->Print(validation_pdf);
    _canv_spectrum        ->Print(validation_pdf);
    _canv_time            ->Print(validation_pdf);
    _canv_pedestal        ->Print(validation_pdf);
    _canv_pulse_charge    ->Print(validation_pdf);
    _canv_current         ->Print(validation_pdf);
    _canv_rates           ->Print(validation_pdf);
    _canv_ncluster        ->Print(validation_pdf+")");
  }
}

bool darkart::od::Validator::multiplicityCut(float height, float multiplicity, float charge){
        return height/multiplicity < (2.563e7 + TMath::Sqrt(1.574e14+1.390e12*(charge-14.40)*(charge-14.40)));
}

void darkart::od::Validator::analyze(art::Event const & e)
{
  // Retrieve data products from art::Events
  art::Handle<darkart::od::ODEventInfo>    event_info;        e.getByLabel(_event_info_tag,   event_info);
  art::Handle<darkart::od::ChannelDataVec> channel_data_vec;  e.getByLabel(_channel_data_tag, channel_data_vec);
  art::Handle<darkart::od::ClusterVec>     clusters_lsv;      e.getByLabel(_cluster_lsv_tag,  clusters_lsv);
  art::Handle<darkart::od::ClusterVec>     clusters_wt;       e.getByLabel(_cluster_wt_tag,   clusters_wt);
  
  
  if (_first_event){
    _run_id = event_info->run_id;
    const double gate_ns =  double(_utils->getLSVRecordLength())/(_utils->getLSVSampleRateGHz());
    const double ref_pos =  double(_utils->getLSVReferencePos());
    _h_lsv_cluster_start_ns       ->SetBins(int(gate_ns/100), -(gate_ns * ref_pos), gate_ns-(gate_ns* ref_pos));
    _h_lsv_cluster_high_start_ns  ->SetBins(int(gate_ns/100), -(gate_ns * ref_pos), gate_ns-(gate_ns* ref_pos));
    _h_lsv_trigger_time_ns        ->SetBins(int(gate_ns/100), -(gate_ns * ref_pos), gate_ns-(gate_ns* ref_pos));
    _first_event = false;
  }
  
  
  // count number of events
  _num_events++;  
  
  // Fill histograms
  if (event_info.isValid()) {
    _h_dt_usec->Fill(event_info->dt_usec);
    
    const int bad_time_alignment = event_info->bad_time_alignment;
    _h_bad_time->Fill(bad_time_alignment);
    
    if (bad_time_alignment>0){
      _bad_events++;
      return;
    }
    
    // Loop over Channels
    if(_plot_rates){
      const size_t nch = channel_data_vec->size();
      for(size_t ch_idx = 0; ch_idx < nch; ch_idx++){
	darkart::od::ChannelData const& channel_data = channel_data_vec->at(ch_idx);
	
	// Check the channel type (lsv = 1, wt = 2, disabled lsv = -1, disabled wt = -2)
	const int channel_type = channel_data.channel_type;
	if ((channel_type <= 0) || (channel_type>2)) continue; // skip all channel types besides lsv, wt
	
	// loop over pulses
	const size_t npulses = channel_data.npulses;
	
	_npulses_sum[ch_idx]             += npulses;
	
	if (channel_type==1){ // LSV
	  _h_lsv_rates    ->Fill(ch_idx, Float_t(npulses));
	}
	
	if (channel_type==2){ // WT
	  _h_wt_rates     ->Fill(ch_idx, Float_t(npulses));
	}
	
	for (size_t ip=0; ip<npulses; ip++){
	  const Float_t pulse_integral  = channel_data.pulses[ip].integral;
	  _pedestal_ch_mean_sum[ch_idx]+= channel_data.pulses[ip].pedestal_mean;
	  _pedestal_ch_rms_sum[ch_idx] += channel_data.pulses[ip].pedestal_rms;
	  _charge_ch_mean_sum[ch_idx]  += pulse_integral;
	  _charge_ch_rms_sum[ch_idx]   += pulse_integral*pulse_integral;

	  if (channel_type==1){ // LSV
	    _h_lsv_current  ->Fill(ch_idx, pulse_integral);
	  }
	  
	  if (channel_type==2){ // WT
	    _h_wt_current   ->Fill(ch_idx, pulse_integral);
	  }
	  
	} // end loop over pulses
	
      } // end loop over channels
    } // end if do plots of rates and current per channel
    
    // Fill n cluster histograms
    const size_t lsv_nclusters = clusters_lsv->size();
    const size_t wt_nclusters  = clusters_wt->size();
    _h_lsv_nclust->Fill(lsv_nclusters);
    _h_wt_nclust ->Fill(wt_nclusters);
    
    //Loop over LSV clusters
    for(size_t cl_idx = 0; cl_idx < lsv_nclusters; cl_idx++){
      const float ene              = clusters_lsv->at(cl_idx).charge;
      const float height           = clusters_lsv->at(cl_idx).height;
      const float max_multiplicity = clusters_lsv->at(cl_idx).max_multiplicity;
      const float start_ns         = clusters_lsv->at(cl_idx).start_ns;
      
      //Fill spectrum for low and high energy
      _h_lsv_spectrum         ->Fill(ene);
      _h_lsv_cluster_start_ns ->Fill(start_ns);
      
      if (start_ns > _late_cut_ns) _h_lsv_spectrum_late->Fill(ene);
      
      if(ene < _lsv_ene_above){
	
	_h_lsv_spectrum_low->Fill(ene);
	
        // multiplicity cut
        if(multiplicityCut(height, max_multiplicity, ene)){
          _h_lsv_spectrum_low_mult_pass->Fill(ene);
	  _counts_low_mult_pass++;
        }
        else {	  
          _h_lsv_spectrum_low_mult_fail->Fill(ene);
	  _counts_low_mult_fail++;
	}
      }
      if(ene >=_lsv_ene_above){
        _h_lsv_spectrum_high->Fill(ene);
        _h_lsv_cluster_high_start_ns->Fill(start_ns);
      }
      if ((start_ns > _prompt_offset_ns + _pre_prompt_ns) && 
	  (start_ns < _prompt_offset_ns + _post_prompt_ns)) 
	{
	  _h_lsv_spectrum_coinc->Fill(ene);
	}
      
    } // end loop over LSV clusters
    
    for(size_t cw_idx = 0; cw_idx < wt_nclusters; cw_idx++){
      
      const float wt_ene              = clusters_wt->at(cw_idx).charge;
      _h_wt_spectrum->Fill(wt_ene);
    } // end loop over WT clusters
    
  } // end if isValid()
  
}

void darkart::od::Validator::set_style(){

  if (_od_val_style) return; // do nothing if style is already set

  const int font = 102; // Courier

  _dscolors.push_back(kBlack);                      // 0: Black
  _dscolors.push_back(TColor::GetColor("#0088EE")); // 1: Blue
  _dscolors.push_back(TColor::GetColor("#66CC00")); // 2: Green
  _dscolors.push_back(TColor::GetColor("#6600CC")); // 3: Purple
  _dscolors.push_back(TColor::GetColor("#CC6600")); // 4: Orange
  _dscolors.push_back(TColor::GetColor("#00CCCC")); // 5: Cyan
  _dscolors.push_back(TColor::GetColor("#CC0000")); // 6: Red
  _dscolors.push_back(TColor::GetColor("#CC00CC")); // 7: Violet
  _dscolors.push_back(TColor::GetColor("#FFEE00")); // 8: Yellow
  _dscolors.push_back(TColor::GetColor("#00CC00")); // 9: Darker green
  _dscolors.push_back(TColor::GetColor("#0000CC")); //10: Darker blue
  _dscolors.push_back(TColor::GetColor("#00CC66")); //11: Blueish green
  _dscolors.push_back(TColor::GetColor("#CC0066")); //13: Violet
  _dscolors.push_back(TColor::GetColor("#A3FF47")); //14: Yellowish green
  _dscolors.push_back(TColor::GetColor("#850AFF")); //15: Deep purple
  _dscolors.push_back(TColor::GetColor("#85FF0A")); //16: Bright green
  _dscolors.push_back(TColor::GetColor("#A347FF")); //17: Light purple

  _od_val_style = new TStyle("od_val_style","od_val_style");
  *_od_val_style = *(gROOT->GetStyle("Plain"));
  
  _od_val_style->SetCanvasColor(kWhite);
  _od_val_style->SetTitleFillColor(kWhite);
  
  _od_val_style->SetName("od_val_style");
  _od_val_style->SetCanvasDefH(475);
  _od_val_style->SetCanvasDefW(800);
  _od_val_style->SetFuncWidth(2);
  _od_val_style->SetHistLineWidth(2);
  _od_val_style->SetLegendBorderSize(0);
  _od_val_style->SetLegendFont(font);
  _od_val_style->SetOptFit(0);    // this is different from DS-50 style
  _od_val_style->SetStatBorderSize(0);
  _od_val_style->SetTitleBorderSize(0);
  _od_val_style->SetDrawBorder(0);
  _od_val_style->SetLabelSize(.04,"xyz");
  _od_val_style->SetTitleSize(.04,"xyz");
  _od_val_style->SetLabelFont(font,"xyz");
  _od_val_style->SetOptStat(0);
  _od_val_style->SetStatFont(font);
  _od_val_style->SetTitleFont(font,"xyz");
  _od_val_style->SetTitleFont(font,"pad");
  _od_val_style->SetStatStyle(0);
  _od_val_style->SetStatX(0.85);            //Stat box x position (top right hand corner)
  _od_val_style->SetStatY(0.85);            //Stat box y position
  _od_val_style->SetStatW(.12);             //Stat box width as fraction of pad size
  _od_val_style->SetStatH(.12);             //Size of each line in stat box
  _od_val_style->SetStatColor(0);           //Stat box fill color
  _od_val_style->SetStatTextColor(1);		//Stat box text color
  _od_val_style->SetStatStyle(1001);		//Stat box fill style!
  _od_val_style->SetStatFont(font);  		//Stat box fond
  _od_val_style->SetStatBorderSize(2);		//Stat box border thickness
  _od_val_style->SetTitleStyle(0);
  _od_val_style->SetTitleX(.2);
  _od_val_style->SetTitleXOffset(1.2);
  _od_val_style->SetTitleYOffset(1.3);
  _od_val_style->SetTitleW(.65);
  _od_val_style->SetTitleY(.98);
  _od_val_style->SetTitleH(.07);
  _od_val_style->SetStatColor(0);
  _od_val_style->SetStatBorderSize(0);
  _od_val_style->SetFillColor(10);
  _od_val_style->SetFillStyle(0);
  _od_val_style->SetTextFont(font);
  _od_val_style->SetCanvasBorderMode(0);
  _od_val_style->SetPadBorderMode(0);
  _od_val_style->SetPadLeftMargin(0.13);
  _od_val_style->SetPadRightMargin(0.13);
  _od_val_style->SetFrameBorderMode(0);
  _od_val_style->SetDrawBorder(0);
  _od_val_style->SetPalette(1,0);

  gROOT->SetStyle("od_val_style");
  gROOT->ForceStyle();

}



DEFINE_ART_MODULE(darkart::od::Validator)
