////////////////////////////////////////////////////////////////////////
// Class:       SignalOverlay
// Module Type: producer
// File:        SignalOverlay_module.cc
//
// Generated at Tue Oct 28 23:00:56 2014 by Alden Fan using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "darkart/Products/Channel.hh"
#include "darkart/Products/Waveform.hh"
#include "darkart/Products/WaveformInfo.hh"
#include "darkart/Products/ProductAssns.hh"

#include "darkart/TpcReco/utilities.hh"
#include "darkart/TpcReco/ByChannel.hh"
#include "darkart/TpcReco/common_algs.hh"
#include "darkart/TpcMC/SignalOverlayer.hh"

namespace darkart {
  namespace MC {
    class SignalOverlay;
  }
}

////////////////////////////////////////////////////////////////////////
// 2014-10-28 AFan
// 
// Modularization of existing electronics MC.
//
// This module takes in simulated waveforms and overlays them on baseline.
// Can overlay on real waveforms or can overwrite real waveforms with fake
// baseline, either flat or simulated.
////////////////////////////////////////////////////////////////////////


class darkart::MC::SignalOverlay : public art::EDProducer {
public:
  explicit SignalOverlay(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SignalOverlay(SignalOverlay const &) = delete;
  SignalOverlay(SignalOverlay &&) = delete;
  SignalOverlay & operator = (SignalOverlay const &) = delete;
  SignalOverlay & operator = (SignalOverlay &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  art::InputTag _sig_wfm_tag;
  art::InputTag _ch_tag;
  art::InputTag _raw_wfm_tag;

  // Helper class for overlaying waveforms
  darkart::SignalOverlayer _helper;

};


darkart::MC::SignalOverlay::SignalOverlay(fhicl::ParameterSet const & p)
  : _sig_wfm_tag(p.get<std::string>("sig_wfm_tag"))
  , _ch_tag(p.get<std::string>("ch_tag"))
  , _raw_wfm_tag(p.get<std::string>("raw_wfm_tag"))
  , _helper(p.get<fhicl::ParameterSet>("params"))
{
  produces<darkart::WaveformVec>();
  produces<darkart::WaveformAssns>();
  produces<darkart::WaveformInfoVec>();
  produces<darkart::WaveformInfoAssns>();
  produces<darkart::WaveformVec>("baseline");
  produces<darkart::WaveformVec>("smearedBaseline");
}

void darkart::MC::SignalOverlay::produce(art::Event & e)
{
  // Vector of signal waveforms, in channel order.
  auto const& sigWfmsHandle = e.getValidHandle<darkart::WaveformVec>(_sig_wfm_tag);
  auto const& sigWfms = *sigWfmsHandle;

  // Retrieve the ChannelVec. The e.getValidHandle<>() method does not play well
  // with making art::Assns, so use explicit art::Handles.
  art::Handle<darkart::ChannelVec> chVecHandle;
  e.getByLabel(_ch_tag, chVecHandle);
  
  // Getter for raw waveforms
  darkart::ByChannel<darkart::Waveform> get_wfm(chVecHandle, e, _raw_wfm_tag);

  // Check that simulated # channels and real # channels is as expected.
  if (chVecHandle->size() != sigWfmsHandle->size())
    throw cet::exception("ProductRetrieval") << "Mis-matching number of channels between simulation and real data";

  // Create data products, which begin empty.
  std::unique_ptr<darkart::WaveformVec>       simWfmVec             (new darkart::WaveformVec);
  std::unique_ptr<darkart::WaveformInfoVec>   simWfmInfoVec         (new darkart::WaveformInfoVec);
  std::unique_ptr<darkart::WaveformAssns>     simWfmAssns           (new darkart::WaveformAssns);
  std::unique_ptr<darkart::WaveformInfoAssns> simWfmInfoAssns       (new darkart::WaveformInfoAssns);
  std::unique_ptr<darkart::WaveformVec>       baselineWfmVec        (new darkart::WaveformVec);
  std::unique_ptr<darkart::WaveformVec>       smearedBaselineWfmVec (new darkart::WaveformVec);
  baselineWfmVec->resize(chVecHandle->size());
  smearedBaselineWfmVec->resize(chVecHandle->size());

  // Loop over real channels to get associated real waveforms. Create new waveforms
  // by overlaying simulated signal.
  for (auto const& ch : *chVecHandle) {

    // Retrieve the channel ID
    darkart::Channel::ChannelID const& chID = ch.channelID;
    int const ich = ch.channel_id();

    // Retrieve the raw waveform
    auto const& raw_wfm = get_wfm(chID); //Ptr.


    // Create simulated waveforms
    darkart::Waveform baseline         = _helper.generateBaseline(*raw_wfm, sigWfms[ich]);
    darkart::Waveform smearedBaseline  = _helper.smearBaseline(baseline, sigWfms[ich]);
    darkart::Waveform sim_wfm          = _helper.overlay(smearedBaseline, sigWfms[ich]);
    darkart::WaveformInfo sim_wfm_info = darkart::fillWaveformInfo(sim_wfm);

    // Add the objects to the corresponding vectors.
    simWfmVec->push_back(sim_wfm);
    simWfmInfoVec->push_back(sim_wfm_info);
    baselineWfmVec->at(ch.channel_id()) = std::move(baseline);
    smearedBaselineWfmVec->at(ch.channel_id()) = std::move(smearedBaseline);

    // Fill the Assns
    util::createAssn( *this, e,
                      chVecHandle, ch,
                      *simWfmVec, sim_wfm,
                      *simWfmAssns );

    util::createAssn( *this, e,
                      chVecHandle, ch,
                      *simWfmInfoVec, sim_wfm_info,
                      *simWfmInfoAssns );


    
  }//Loop over channels

  // Put our complete products into the Event
  e.put(std::move(simWfmVec));
  e.put(std::move(simWfmInfoVec));
  e.put(std::move(simWfmAssns));
  e.put(std::move(simWfmInfoAssns));
  e.put(std::move(baselineWfmVec), "baseline");
  e.put(std::move(smearedBaselineWfmVec), "smearedBaseline");
}

DEFINE_ART_MODULE(darkart::MC::SignalOverlay)
