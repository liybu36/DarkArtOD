////////////////////////////////////////////////////////////////////////
// Class:       SumWaveformGenerator
// Module Type: producer
// File:        SumWaveformGenerator_module.cc
//
// Generated at Wed Feb  4 12:16:53 2015 by Shawn Westerdale using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib/exception.h"

#include <iostream>
#include <memory>
#include "darkart/ODProducts/SumWF.hh"
#include "darkart/ODProducts/RunInfo.hh"
#include "darkart/ODReco/Tools/Utilities.hh"
//Submodules
#include "darkart/ODReco/Submodules/AmplitudeWaveformGenerator.hh"
#include "darkart/ODReco/Submodules/DiscriminatorWaveformGenerator.hh"

//for validdation
//#include "darkart/ODProducts/ODEventInfo.hh"
//#include <fstream>

namespace darkart {
  namespace od {
    class SumWaveformGenerator;
  }
}

class darkart::od::SumWaveformGenerator : public art::EDProducer {
public:
  explicit SumWaveformGenerator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SumWaveformGenerator(SumWaveformGenerator const &) = delete;
  SumWaveformGenerator(SumWaveformGenerator &&) = delete;
  SumWaveformGenerator & operator = (SumWaveformGenerator const &) = delete;
  SumWaveformGenerator & operator = (SumWaveformGenerator &&) = delete;

  void beginRun(art::Run & r) override;
  void produce(art::Event & e) override;

  

private:

  int _verbosity;
  std::string _input_pulses;
  std::string _parent_wf;
  std::string _sum_mode;
  int _sum_wf_size;

  int _channel_type; //0: default, 1: LSV, 2: WT, -1: disabled LSV, -2: disabled WT

  // Initialize submodules that may be used
  AmplitudeWaveformGenerator *_amplitude_waveform_generator;
  DiscriminatorWaveformGenerator *_discriminator_waveform_generator;

  // Other things that are useful for this module to know about
  art::ServiceHandle<darkart::od::Utilities> _utils;
};


darkart::od::SumWaveformGenerator::SumWaveformGenerator(fhicl::ParameterSet const & p)
  : _verbosity(p.get<int>("detail.verbosity", 0))
  , _input_pulses(p.get<std::string>("input_pulses", "pulsecorrector"))
  , _parent_wf(p.get<std::string>("parent_wf", "none"))
  , _sum_mode(p.get<std::string>("sum_mode", "default"))
  , _sum_wf_size(-1)
  , _channel_type(p.get<int>("channel_type", 0))
  , _amplitude_waveform_generator(0)
  , _discriminator_waveform_generator(0)
{
  // By default, all generators will be used. However, the user can specify a mode
  // That will only use one at a time, if this is to be called in multiple instances.
  // Other run modes may also use different subsets of generators
  if(_sum_mode == "amplitude"){
    _amplitude_waveform_generator = new AmplitudeWaveformGenerator(p.get<fhicl::ParameterSet>("amplitudesumparams"),_channel_type);
  }
  else if(_sum_mode == "discriminator"){
    _discriminator_waveform_generator = new DiscriminatorWaveformGenerator(p.get<fhicl::ParameterSet>("discriminatorsumparams"),_channel_type);
  }
  else if(_sum_mode == "default"){
    _amplitude_waveform_generator = new AmplitudeWaveformGenerator(p.get<fhicl::ParameterSet>("amplitudesumparams"),_channel_type);
    _discriminator_waveform_generator = new DiscriminatorWaveformGenerator(p.get<fhicl::ParameterSet>("discriminatorsumparams"),_channel_type);
  }
  else {
    throw cet::exception("SumWaveformGenerator") << "Unsupported sum_mode: " << _sum_mode << std::endl;
  }
  
  produces<darkart::od::SumWF>();
}

void darkart::od::SumWaveformGenerator::beginRun(art::Run & r)
{
  art::Handle<darkart::od::RunInfo> riHandle;
  r.getByLabel("ODReader",riHandle);
  _sum_wf_size = _utils->getRecordLength(_channel_type);
  if(_discriminator_waveform_generator)
    _discriminator_waveform_generator->setUtils(_utils->getPointer());

}


void darkart::od::SumWaveformGenerator::produce(art::Event & e)
{

  // Create the sum waveform that will get filled here
  // If the user chooses to pass a sum waveform from a previous instance
  // or another module, it should be specified by the _parent_wf
  std::unique_ptr<darkart::od::SumWF> sumwf(new darkart::od::SumWF());
  if(_parent_wf == "none"){
    _utils->zeroSumWF(*sumwf, _channel_type);

    // If this detector is not active, just leave it blank
    if(_sum_wf_size == -1){
      e.put(std::move(sumwf));
      return;
    }
  }
  else{
    auto const & parent_sum_waveform = e.getValidHandle<darkart::od::SumWF>(_parent_wf);
    *sumwf = *parent_sum_waveform;
  }
  
  // check that sum_wf is expected size
  if ((int)sumwf->size() != _sum_wf_size)
    throw cet::exception("SumWaveformGenerator") << "sum_wf is not expected size: " << sumwf->size() << " vs " << _sum_wf_size << std::endl;
  
  // Get ChannelData and ChannelWFs vectors
  auto const &channel_data_vec = e.getValidHandle<darkart::od::ChannelDataVec>(_input_pulses);
  auto const &channel_wfs_vec = e.getValidHandle<darkart::od::ChannelWFsVec>(_input_pulses);

  // Run whichever generators are being used, in this order
  // If you want to run them in a different order, you'll have to
  // Run multiple instances of this module, one at a time. Though I have
  // no idea why you would do that
  if(_amplitude_waveform_generator)
    _amplitude_waveform_generator->sum(*channel_data_vec, *channel_wfs_vec, *sumwf, -1);
  if(_discriminator_waveform_generator)
    _discriminator_waveform_generator->sum(*channel_data_vec, *sumwf, -1);

  e.put(std::move(sumwf));
}

DEFINE_ART_MODULE(darkart::od::SumWaveformGenerator)
