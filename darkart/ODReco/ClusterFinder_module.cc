////////////////////////////////////////////////////////////////////////
// Class:       ClusterFinder
// Module Type: producer
// File:        ClusterFinder_module.cc
//
// Generated at Thu Feb  5 09:04:16 2015 by Shawn Westerdale using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

//#include "darkart/ODProducts/ODEventInfo.hh"

//Submodules
#include "darkart/ODReco/Submodules/AmplitudeClusterFinder.hh"
#include "darkart/ODReco/Submodules/TopDownClusterFinder.hh"

namespace darkart {
  namespace od {
    class ClusterFinder;
  }
}

class darkart::od::ClusterFinder : public art::EDProducer {
public:
  explicit ClusterFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ClusterFinder(ClusterFinder const &) = delete;
  ClusterFinder(ClusterFinder &&) = delete;
  ClusterFinder & operator = (ClusterFinder const &) = delete;
  ClusterFinder & operator = (ClusterFinder &&) = delete;

  // Required functions.
  void beginRun(art::Run & r) override;
  void produce(art::Event & e) override;


private:

  std::string _mode;
  std::string _input_waveform;
  int _channel_type;

  // Initialize candidate clustering algorithms
  //------------------------------------------------------------------------------
  // This algorithm scans the waveform and identifies wherever
  // the amplitude passes some threshold to identify the start of a cluster
  AmplitudeClusterFinder *_amplitude_cluster_finder;
  // This algorithm starts by identifying peaks in the sum waveform, and searches
  // before and after the peak to find the start and end of clusters
  TopDownClusterFinder *_top_down_cluster_finder;

  // Other things that are useful for this module to know about
  art::ServiceHandle<darkart::od::Utilities> _utils;

};

void darkart::od::ClusterFinder::beginRun(art::Run &)
{
  //  art::Handle<darkart::od::RunInfo> riHandle;
  //  r.getByLabel("ODReader",riHandle);
}

darkart::od::ClusterFinder::ClusterFinder(fhicl::ParameterSet const & p)
  : _mode(p.get<std::string>("mode","none"))
  , _input_waveform(p.get<std::string>("input_waveform","none"))
  , _channel_type(p.get<int>("channel_type",0))
  , _amplitude_cluster_finder(0)
  , _top_down_cluster_finder(0)
{
  if(_mode == "amplitude")
    _amplitude_cluster_finder = new AmplitudeClusterFinder(p.get<fhicl::ParameterSet>("amplitudeparams"),_channel_type);
  else if(_mode == "topdown")
    _top_down_cluster_finder = new TopDownClusterFinder(p.get<fhicl::ParameterSet>("topdownparams"),_channel_type);
  else
    throw cet::exception("ClusterFinder") << "Invalid cluster algorithm choice: mode = " << _mode;

  produces<darkart::od::ClusterVec>();
}

void darkart::od::ClusterFinder::produce(art::Event & e)
{

  //-------debug----------
  //auto const event_handle = e.getValidHandle<darkart::od::ODEventInfo>("ODReader");
  //int event_id = event_handle->event_id;
  //-----debug------------

  // This is the cluster vector that will be filled by the submodule
  std::unique_ptr<darkart::od::ClusterVec> cluster_vec(new darkart::od::ClusterVec());

  // Get the input sum waveform
  if(_input_waveform == "none")
    throw cet::exception("ClusterFinder") << "Invalid cluster input sum waveform: input_waveform = " << _input_waveform;
  auto const & sumwf = e.getValidHandle<darkart::od::SumWF>(_input_waveform);
  
  // Call whichever algorithm has been chosen
    if(_amplitude_cluster_finder){
    _amplitude_cluster_finder->setUtilities(_utils->getPointer());
    _amplitude_cluster_finder->findClusters(*sumwf, *cluster_vec);
  }
  else if(_top_down_cluster_finder){
    _top_down_cluster_finder->setUtilities(_utils->getPointer());
    _top_down_cluster_finder->findClusters(*sumwf, *cluster_vec);
  }
  
  
 


  //For validation===================
  /*if (_channel_type==1) {
    auto const event_handle = e.getValidHandle<darkart::od::EventInfo>("ODReader");
    int ev = event_handle->event_id;
        
    ofstream myfile; std::string fname = "darkartOD_ev"+std::to_string(ev)+"_cluster_td"; myfile.open (fname.c_str());
    
    //debug
    std::cout<<"num of cluster===>"<<cluster_vec->size()<<"\n";
    myfile.precision(15);
    myfile<<"cluster_id\n";   for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).cluster_id<<"\n"; }       myfile<<"-----\n";
    myfile<<"start_sample\n"; for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).start_sample<<"\n"; }     myfile<<"-----\n";
    myfile<<"end_sample\n";   for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).end_sample<<"\n"; }       myfile<<"-----\n";
    myfile<<"peak_sample\n";  for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).peak_sample<<"\n"; }      myfile<<"-----\n";
    myfile<<"max_multiplicity\n";     for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).max_multiplicity<<"\n"; } myfile<<"-----\n";
    myfile<<"charge\n";       for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).charge<<"\n"; }           myfile<<"-----\n";
    myfile<<"height\n";       for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).height<<"\n"; }           myfile<<"-----\n";
    myfile<<"satrt_ns\n";     for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).start_ns<<"\n"; }         myfile<<"-----\n";
    myfile<<"end_ns\n";       for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).end_ns<<"\n"; }           myfile<<"-----\n";
    myfile<<"peak_ns\n";      for(unsigned int i=0; i<cluster_vec->size(); i++) { myfile<<cluster_vec->at(i).peak_ns<<"\n"; }          myfile<<"-----\n";
 
    myfile.close();
  }
  */
  //for validation=====================

  // Insert the products into the ART event
  e.put(std::move(cluster_vec));
}

DEFINE_ART_MODULE(darkart::od::ClusterFinder)
