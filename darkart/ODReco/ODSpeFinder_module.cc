////////////////////////////////////////////////////////////////////////
// Class:       ODSpeFinder
// Module Type: analyzer
// File:        ODSpeFinder_module.cc
//
// Generated at Wed Mar 25 15:25:41 2015 by Xin Xiang using artmod
// from cetpkgsupport v1_08_04.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "darkart/ODProducts/ChannelData.hh"
#include "darkart/ODReco/Tools/Utilities.hh"

#include <TCanvas.h>
#include <TFile.h>
#include <TTree.h>
#include <TH1F.h>
#include <TF1.h>
#include <TMath.h>
#include <TLine.h>
#include "TStyle.h"

#include <memory>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <fstream>

namespace darkart {
  namespace od {
    class ODSpeFinder;
  }
}

class darkart::od::ODSpeFinder : public art::EDAnalyzer {
public:
  explicit ODSpeFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ODSpeFinder(ODSpeFinder const &) = delete;
  ODSpeFinder(ODSpeFinder &&) = delete;
  ODSpeFinder & operator = (ODSpeFinder const &) = delete;
  ODSpeFinder & operator = (ODSpeFinder &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void endJob() override;

  //fitting function
  TF1 fitHistoByGaus(TH1F*);

private:
  std::string _channel_data_tag;  
  std::string _mode;
  int _save_spe_to_file;
  std::string _spe_filename;

  art::ServiceHandle<darkart::od::Utilities> _utils;
  art::ServiceHandle<art::TFileService> _tfs;

  int _n_chan;

  //histogram plots
  TH1F** _h_charge;
  TH1F** _h_pulse_start;
  int _nbin;
  float _charge_min;
  float _charge_max;
  //canvas
  TCanvas** _canv;
  

  

  
};


darkart::od::ODSpeFinder::ODSpeFinder(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _channel_data_tag (p.get<std::string>( "channel_data_tag" ))  
  , _mode (p.get<std::string>( "mode" , "default"))
  , _save_spe_to_file (p.get<int>( "save_spe_to_file" , 0))
  , _spe_filename (p.get<std::string>( "spe_filename" , "spe_test.txt"))
  , _tfs() 
  , _n_chan(256)
  , _nbin(800)
  , _charge_min(0)
  , _charge_max(2.5e-9)
 
 // More initializers here.
{ 
  if (_mode == "default")
    throw cet::exception("ROIIntegrator")<<"Error: in FHiCL file, mode is not recognize (option: gaus, gaus_expo) \n";

}


void darkart::od::ODSpeFinder::beginJob()
{

  //init histogram and canvas
  _h_charge = new TH1F* [_n_chan];
  _h_pulse_start = new TH1F* [_n_chan];
  _canv = new TCanvas* [_n_chan];
  for (int ch=0; ch < _n_chan; ch++){
    std::string charge_name_str = "chan"+std::to_string(ch);
    std::string charge_title_str = "Channel"+ std::to_string(ch)+ " Spectrum before SPE normalization; pulse integral [v s]; number of pulses";
    std::string start_name_str = "chan"+std::to_string(ch)+"_pulse_start";
    _h_charge[ch] = _tfs->make<TH1F>(charge_name_str.c_str(), charge_title_str.c_str(), _nbin, _charge_min, _charge_max);
    //TO DO: properly get the first sample time and last sample time
    _h_pulse_start[ch] = _tfs->make<TH1F>(start_name_str.c_str(), "pulse start time ; start time [ns]", _nbin, -1e+3, 0.8e+4 );
    _canv[ch] = _tfs->make<TCanvas>(charge_name_str.c_str(), charge_title_str.c_str());
  }
}


void darkart::od::ODSpeFinder::analyze(art::Event const & e)
{
  art::Handle<darkart::od::ChannelDataVec> channel_data_vec;  
  e.getByLabel(_channel_data_tag, channel_data_vec);
  for (size_t ch=0; ch< channel_data_vec->size(); ch++) {
    darkart::od::ChannelData const& channel_data = channel_data_vec->at(ch);
    const int npulses = channel_data.npulses;
    float total_pulse_integral =0;
    for(int p=0; p<npulses; p++) {
      darkart::od::ChannelData::Pulse const& pulse = channel_data.pulses[p];
      total_pulse_integral += -pulse.integral;
      _h_pulse_start[ch]->Fill(pulse.start_ns);

      //debug
      //if (pulse.integral<0 && pulse.integral>-0.5e-10)
      //	std::cout<<"ch"<<ch<<"   pulse"<<p<<":   integral="<<pulse.integral<<"   peak="<<pulse.peak_amplitude<<"\n";
    }
    if (npulses>0 && total_pulse_integral>0)
      _h_charge[ch]->Fill(total_pulse_integral);
  }
}


void darkart::od::ODSpeFinder::endJob()
{
  //debug                                                                                                                                                                                                         
  //std::cout<<"channel_type=1. ref pos:"<<_utils->getReferencePos(1)<<" record length "<<_utils->getRecordLength(1)<<"\n";
  //std::cout<<"channel_type=2. ref pos:"<<_utils->getReferencePos(2)<<" record length "<<_utils->getRecordLength(2)<<"\n";
  //std::cout<<"channel_type=-1. ref pos:"<<_utils->getReferencePos(-1)<<" record length "<<_utils->getRecordLength(-1)<<"\n";
  //std::cout<<"channel_type=-2. ref pos:"<<_utils->getReferencePos(-2)<<" record length "<<_utils->getRecordLength(-2)<<"\n";

  //keep stylish
  gStyle->SetOptFit(1);
  gStyle->SetStatY(0.92);
  gStyle->SetStatX(0.95);
  gStyle->SetStatW(0.18);
  gStyle->SetStatH(0.12);

  ofstream outfile;
  if (_save_spe_to_file == 1) {
    outfile.open (_spe_filename.c_str());
  }

  for (int ch=0; ch<_n_chan; ch++) {

    _h_pulse_start[ch]->Write();
    float spe_mean =0; TF1 func;
    if (_mode == "gaus") {
      
      func = fitHistoByGaus(_h_charge[ch]);
      
      if (_h_charge[ch]->GetEntries() > 1000) 
	spe_mean = -func.GetParameter(1);
      if (_save_spe_to_file==1)
	outfile<<ch<<'\t'<<spe_mean<<"\n";
    }
    //draw
    _canv[ch]->cd();  _h_charge[ch]->Draw(); func.Draw("Same");
    _canv[ch]->Write();
  
  }//end channel loop

  if (_save_spe_to_file == 1) {
    outfile.close();
  }
}


TF1 darkart::od::ODSpeFinder::fitHistoByGaus( TH1F* h)
{
  TF1 gaus("gaus","gaus");
  const int binmax = h->GetMaximumBin();
  const Double_t peak_max = h->GetXaxis()->GetBinCenter(binmax);
  const Float_t range_min = peak_max - 3e-10;
  const Float_t range_max = peak_max + 3e-10;

  h->Fit(&gaus,"LQRN","", range_min, range_max);
  gaus.SetRange(range_min, range_max);
  return gaus;
}

//void darkart::od::ODSpeFinder::saveSpeToFile(TF1 func, int chan )


DEFINE_ART_MODULE(darkart::od::ODSpeFinder)
