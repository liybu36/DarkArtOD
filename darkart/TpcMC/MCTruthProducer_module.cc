////////////////////////////////////////////////////////////////////////
// Class:       MCTruthProducer
// Module Type: producer
// File:        MCTruthProducer_module.cc
//
// Generated at Sun Nov  2 01:17:26 2014 by Alden Fan using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Utilities/Exception.h"
#include "cetlib/exception.h"

#include <memory>
#include <iostream>
#include <algorithm>

#include "darkart/Products/Channel.hh"
#include "darkart/Products/Waveform.hh"
#include "darkart/Products/PeCharge.hh"
#include "darkart/Products/MCTruth.hh"

#include "darkart/TpcReco/ByChannel.hh"
#include "darkart/TpcReco/common_algs.hh"

#include "TTree.h"

namespace darkart {
  namespace MC {
    class MCTruthProducer;
  }
}

////////////////////////////////////////////////////////////////////////
// 2014-11-01 AFan
//
// Modularization of electronics MC. Retrieve MC data products and fill
// MCTruth data product.
////////////////////////////////////////////////////////////////////////


class darkart::MC::MCTruthProducer : public art::EDProducer {
public:
  explicit MCTruthProducer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MCTruthProducer(MCTruthProducer const &) = delete;
  MCTruthProducer(MCTruthProducer &&) = delete;
  MCTruthProducer & operator = (MCTruthProducer const &) = delete;
  MCTruthProducer & operator = (MCTruthProducer &&) = delete;

  // Required functions.
  void beginRun(art::Run & r) override;
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  art::InputTag _pe_charges_tag;
  art::InputTag _spe_tag;
  art::InputTag _ch_tag;
  art::InputTag _sim_waveform_tag;
  art::InputTag _sim_baseline_tag;

  double _fixed_time; //[ns]
  double _fixed2_time; //[ns]
  double _prompt_time; //[ns]

  
  double _spe_mean;

  TTree* _tree;
  MCTruth* mctruth;
};


darkart::MC::MCTruthProducer::MCTruthProducer(fhicl::ParameterSet const & p)
  : _pe_charges_tag(p.get<std::string>("pe_charges_tag"))
  , _spe_tag(p.get<std::string>("spe_tag"))
  , _ch_tag(p.get<std::string>("ch_tag"))
  , _sim_waveform_tag(p.get<std::string>("sim_waveform_tag"))
  , _sim_baseline_tag(p.get<std::string>("sim_baseline_tag"))
  , _fixed_time(p.get<double>("fixed_time"))
  , _fixed2_time(p.get<double>("fixed2_time"))
  , _prompt_time(p.get<double>("prompt_time"))
  , mctruth(nullptr)
{
  produces<MCTruth>();

  art::ServiceHandle<art::TFileService> tfs;
  _tree = tfs->make<TTree>("MCTruth", "Events");
  _tree->Branch("mctruth", &mctruth);
}

void darkart::MC::MCTruthProducer::beginRun(art::Run & r)
{
  art::Handle<double> speMeanHandle; r.getByLabel(_spe_tag, speMeanHandle);
  _spe_mean = *speMeanHandle;
}

void darkart::MC::MCTruthProducer::produce(art::Event & e)
{

  
  auto const& peVecVecHandle = e.getValidHandle<std::vector<PeChargeVec> >(_pe_charges_tag);
  art::Handle<darkart::ChannelVec> chVecHandle; e.getByLabel(_ch_tag, chVecHandle);
  auto const& simBaselineVecHandle = e.getValidHandle<darkart::WaveformVec>(_sim_baseline_tag);
  darkart::ByChannel<darkart::Waveform> get_sig_wfm(chVecHandle, e, _sim_waveform_tag);

  
  mctruth->clear();

  mctruth->event_id = e.event();
  const int nchannels = peVecVecHandle->size();
  mctruth->resize(nchannels);


  for (int ch=0; ch<nchannels; ++ch) {
    mctruth->ch_id[ch] = ch;
    
    PeChargeVec const& peVec = peVecVecHandle->at(ch);

    for (auto const& pe : peVec) {
      double time = pe.time;
      double charge = pe.charge / _spe_mean;
      mctruth->npe    += 1;
      mctruth->charge += charge;
      mctruth->ch_npe[ch] += 1;
      if (time <= _fixed_time) {
        mctruth->npe_fixed    += 1;
        mctruth->charge_fixed += charge;
        mctruth->ch_npe_fixed[ch] += 1;
      } //fixed
      if (time <= _fixed2_time) {
        mctruth->npe_fixed2    += 1;
        mctruth->charge_fixed2 += charge;
        mctruth->ch_npe_fixed2[ch] += 1;
      } //fixed2
      if (time >= 0 && time <= _prompt_time) {
        mctruth->npe_prompt    += 1;
        mctruth->charge_prompt += charge;
        mctruth->ch_npe_prompt[ch] += 1;
      } //prompt
      else if (time > _prompt_time) {
        mctruth->npe_late    += 1;
        mctruth->charge_late += charge;
        mctruth->ch_npe_late[ch] += 1;
        if (time <= _fixed_time) {
          mctruth->npe_late_fixed    += 1;
          mctruth->charge_late_fixed += charge;
          mctruth->ch_npe_late_fixed[ch] += 1;
        } //late_fixed
      } //late

    }// loop over charges

    
    auto const& sig_wfm = get_sig_wfm(ch); //Ptr
    auto const& baseline = simBaselineVecHandle->at(ch);
      
    
    int zero_samp = sig_wfm->TimeToSample(0, true);
    int fixed_samp = sig_wfm->TimeToSample(_fixed_time/1000, true);
    int fixed2_samp = sig_wfm->TimeToSample(_fixed2_time/1000, true);
    int prompt_samp = sig_wfm->TimeToSample(_prompt_time/1000, true);

    double ch_signal           = (darkart::integrate(*sig_wfm) -
                                  darkart::integrate(baseline) ); //full integral
    mctruth->ch_signal[ch] += ch_signal/_spe_mean;
    
    double ch_signal_fixed     = (darkart::integrate(*sig_wfm, zero_samp, fixed_samp) -
                                  darkart::integrate(baseline, zero_samp, fixed_samp) );
    mctruth->ch_signal_fixed[ch] += ch_signal_fixed/_spe_mean;
    
    double ch_signal_fixed2    = (darkart::integrate(*sig_wfm, zero_samp, fixed2_samp) -
                                  darkart::integrate(baseline, zero_samp, fixed2_samp) );
    mctruth->ch_signal_fixed2[ch] += ch_signal_fixed2/_spe_mean;
    
    double ch_signal_prompt    = (darkart::integrate(*sig_wfm, zero_samp, prompt_samp) -
                                  darkart::integrate(baseline, zero_samp, prompt_samp) );
    mctruth->ch_signal_prompt[ch] += ch_signal_prompt/_spe_mean;
    
    double ch_signal_late      = (darkart::integrate(*sig_wfm, prompt_samp, UINT_MAX) - 
                                  darkart::integrate(baseline, prompt_samp, UINT_MAX) );
    mctruth->ch_signal_late[ch] += ch_signal_late/_spe_mean;
    
    double ch_signal_late_fixed = ch_signal_fixed - ch_signal_prompt;
    mctruth->ch_signal_late_fixed[ch] += ch_signal_late_fixed/_spe_mean;

    mctruth->signal            += -ch_signal/_spe_mean;
    mctruth->signal_fixed      += -ch_signal_fixed/_spe_mean;
    mctruth->signal_fixed2     += -ch_signal_fixed2/_spe_mean;
    mctruth->signal_prompt     += -ch_signal_prompt/_spe_mean;
    mctruth->signal_late       += -ch_signal_late/_spe_mean;
    mctruth->signal_late_fixed += -ch_signal_late_fixed/_spe_mean;
  }// loop over channels

  _tree->Fill();


  
  std::unique_ptr<MCTruth> truth(new MCTruth(*mctruth));
  e.put(std::move(truth));
  
}

DEFINE_ART_MODULE(darkart::MC::MCTruthProducer)
