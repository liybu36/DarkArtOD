////////////////////////////////////////////////////////////////////////
// Class:       ROIIntegrator
// Module Type: producer
// File:        ROIIntegrator_module.cc
//
// Generated at Thu Feb 12 12:49:04 2015 by Xin Xiang using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "darkart/ODReco/Tools/Utilities.hh"
#include "darkart/ODProducts/ROI.hh"
#include "darkart/ODProducts/ROICfg.hh"
#include "darkart/ODProducts/SumWF.hh"
#include "darkart/ODProducts/RunInfo.hh"

//debug
//#include "darkart/ODProducts/ODEventInfo.hh"
//#include <fstream>

#include <memory>
#include <iostream>


namespace darkart {
  namespace od {
    class ROIIntegrator;
  }
}

class darkart::od::ROIIntegrator : public art::EDProducer {
public:
  explicit ROIIntegrator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ROIIntegrator(ROIIntegrator const &) = delete;
  ROIIntegrator(ROIIntegrator &&) = delete;
  ROIIntegrator & operator = (ROIIntegrator const &) = delete;
  ROIIntegrator & operator = (ROIIntegrator &&) = delete;

  //Operations over ROI
  float integrateROI(art::ValidHandle<darkart::od::SumWF>, float, float, float);
  int findMultiplicity(art::ValidHandle<darkart::od::SumWF>, float, float, float);

  // Required functions.
  void produce(art::Event & e) override;
  void beginRun(art::Run & r) override;

private:

  // Declare member data here.
  std::vector<float> _roi_start_ns;
  std::vector<float> _roi_end_ns;
  std::vector<float> _roi_label;
  float _prompt_offset_ns;
  int _channel_type;
  std::string _input_waveform;  
  std::string _run_info_tag;  
  int _verbosity;

  art::ServiceHandle<darkart::od::Utilities> _utils;
  //float _lsv_sample_rate_Hz;
  //float _wt_sample_rate_Hz;

  float _HzToGHz;
 };



//constructor
darkart::od::ROIIntegrator::ROIIntegrator(fhicl::ParameterSet const & p)
  : _roi_start_ns(p.get<std::vector<float>>("roi_start_ns"),{})
  , _roi_end_ns(p.get<std::vector<float>>("roi_end_ns"),{})
  , _roi_label(p.get<std::vector<float>>("roi_label"),{})
  , _channel_type(p.get<int>("channel_type", 0))
  , _input_waveform(p.get<std::string>("input_waveform","none"))
  , _verbosity(p.get<int>("verbosity", 0))
  , _HzToGHz(1e-9)
{
  //check the same size
  if ((_roi_start_ns.size() != _roi_end_ns.size()) || (_roi_start_ns.size() != _roi_label.size()) )
    throw cet::exception("ROIIntegrator")<<"Error: your roi_start, roi_end, roi_label does not have the same size \n";

  //check proper roi_start and roi_end
  for (unsigned int i=0; i<_roi_start_ns.size(); i++) {
    if (_roi_start_ns.at(i) >= _roi_end_ns.at(i))
      throw cet::exception("ROIIntegrator") << "Error: your roi_start_ns("<<_roi_start_ns.at(i)<<") is greater or equal to roi_end_ns("<<_roi_end_ns.at(i)<<") \n";
  }
  
  // Call appropriate produces<>() functions here.
  produces<darkart::od::ROI>();
  produces<darkart::od::ROICfg>();
  
  if (_verbosity==2)
    LOG_INFO("ROIIntegrator") << "DEBUG: Check to see if constructor get called. So yes.";
}


void darkart::od::ROIIntegrator::beginRun(art::Run &)
{
  _prompt_offset_ns = _utils->getPromptOffsetNs();
}



void darkart::od::ROIIntegrator::produce(art::Event & e)
{
  //check inputs
  if (_roi_start_ns.size() == 0)
    return;
  if (_roi_end_ns.size() == 0)
    return;
  if (_roi_label.size() == 0)
    return;


  //variables will be saved to ROI.hh and ROICfg.hh
  std::unique_ptr<darkart::od::ROI> roi_ptr(new darkart::od::ROI());
  std::unique_ptr<darkart::od::ROICfg> roicfg_ptr(new darkart::od::ROICfg()); 

  const auto sum_wf_handle = e.getValidHandle<darkart::od::SumWF>(_input_waveform);

  if (_verbosity ==2) {
   LOG_INFO("ROIIntegrator")<<"DEBUG: the size of _roi_start_ns is "<<_roi_start_ns.size();
  }

  float integral=0;
  int multiplicty =0;
  for (int roiNum=0; roiNum< (int)_roi_start_ns.size() ; roiNum++) {
    double start_time_ns=_prompt_offset_ns+_roi_start_ns.at(roiNum);
    double end_time_ns=_prompt_offset_ns+_roi_end_ns.at(roiNum);

    //check: first_samp_time_ns < roi_start_time_ns && roi_end_time_ns< last_samp_time_ns
    const double first_samp_time_ns= sum_wf_handle->at(0).sample_ns;
    const double last_samp_time_ns = sum_wf_handle->at(sum_wf_handle->size()-1).sample_ns;
    if (first_samp_time_ns > start_time_ns)
      start_time_ns = first_samp_time_ns;
    if (last_samp_time_ns< start_time_ns)
      start_time_ns = last_samp_time_ns;
    if (first_samp_time_ns > end_time_ns)
      end_time_ns = first_samp_time_ns;
    if (last_samp_time_ns< end_time_ns)
      end_time_ns = last_samp_time_ns;
    
    integral = integrateROI(sum_wf_handle, start_time_ns, end_time_ns, (float) _utils->getSampleRateHz(_channel_type));
    multiplicty = findMultiplicity(sum_wf_handle, start_time_ns, end_time_ns, (float) _utils->getSampleRateHz(_channel_type));
        
    roi_ptr->id_vec.push_back(roiNum);
    roi_ptr->charge_vec.push_back(integral);
    roi_ptr->max_multiplicity_vec.push_back(multiplicty);

    if (_verbosity ==2) {
      LOG_INFO("ROIIntegrator")<<"DEBUG: charge in ROI: "<<integral<<" pe";
      LOG_INFO("ROIIntegrator")<<"DEBUG: multiplicity in ROI: "<<multiplicty;
    }

  }


  roicfg_ptr->start_ns_vec = _roi_start_ns;
  roicfg_ptr->end_ns_vec = _roi_end_ns;
  for (unsigned int i =0; i<_roi_start_ns.size(); i++)
    roicfg_ptr->id_vec.push_back(i);

  e.put(std::move(roi_ptr));
  e.put(std::move(roicfg_ptr));

}


int darkart::od::ROIIntegrator::findMultiplicity(art::ValidHandle<darkart::od::SumWF> wf_handle, float roi_start_time_ns, float roi_end_time_ns, float sample_rate_Hz)
{

  const double first_samp_time_ns=wf_handle->at(0).sample_ns;
  const double last_samp_time_ns=wf_handle->at(wf_handle->size()-1).sample_ns;
 
  //check: first_samp_time_ns < roi_start_time_ns && roi_end_time_ns< last_samp_time_ns                  
  if ( (first_samp_time_ns > roi_start_time_ns) || (last_samp_time_ns< roi_end_time_ns) ) {
    throw cet::exception("ROIIntegrator")<< "Error: ROI defined from "
					 <<roi_start_time_ns
					 <<" ns to "
					 <<roi_end_time_ns
					 <<" ns out of range (the waveform starts at "
					 <<first_samp_time_ns
					 <<" ns and ends at "
					 <<last_samp_time_ns
					 <<" ns) \n";
  }

  const int roi_start_samp = (roi_start_time_ns-first_samp_time_ns)*sample_rate_Hz*_HzToGHz;
  const int roi_end_samp = (roi_end_time_ns-first_samp_time_ns)*sample_rate_Hz*_HzToGHz;
  int mult=0;
  for (int i =roi_start_samp; i < roi_end_samp; i++) {
    if (wf_handle->at(i).amplitude_discr > mult)
      mult = wf_handle->at(i).amplitude_discr;
  }

  /* Attempt to use lambdas in std::max_element. Unsure how reliable it is.
  std::vector<darkart::od::SumWF>:: iterator it;
  std::max_element( wf_handle->begin()+int(roi_start_samp), wf_handle->begin()+int(roi_end_samp), []( a, Size b){ return a.amplitude_discr < b.amplitude_discr; } );
  */

  return mult ;

}


//implement the function that actually does the integral
float darkart::od::ROIIntegrator::integrateROI(art::ValidHandle<darkart::od::SumWF> wf_handle, float roi_start_time_ns, float roi_end_time_ns, float sample_rate_Hz)
{
  const double ns = 1e-9;
  const double first_samp_time_ns=wf_handle->at(0).sample_ns;
  const double last_samp_time_ns=wf_handle->at(wf_handle->size()-1).sample_ns;

  //check: first_samp_time_ns < roi_start_time_ns && roi_end_time_ns< last_samp_time_ns
  if ( (first_samp_time_ns > roi_start_time_ns) || (last_samp_time_ns< roi_end_time_ns) ) {
    throw cet::exception("ROIIntegrator")<< "Error: ROI defined from "
					 <<roi_start_time_ns
					 <<" ns to "
					 <<roi_end_time_ns
					 <<" ns out of range (the waveform starts at "
					 <<first_samp_time_ns
					 <<" ns and ends at "
					 <<last_samp_time_ns
					 <<" ns) \n"; 
  }
  
  //find first and last samples corresponding to defined ROI
  const int roi_start_samp = (roi_start_time_ns-first_samp_time_ns)*sample_rate_Hz*ns;
  const int roi_end_samp = (roi_end_time_ns-first_samp_time_ns)*sample_rate_Hz*ns;  
  float integral = 0;
  for(int i=roi_start_samp; i<roi_end_samp; i++)
    {
      integral += wf_handle->at(i).amplitude;
    }
  integral *= 1./sample_rate_Hz;    //unit [pe]
  return integral;
}

DEFINE_ART_MODULE(darkart::od::ROIIntegrator)
