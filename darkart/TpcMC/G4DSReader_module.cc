////////////////////////////////////////////////////////////////////////
// Class:       G4DSReader
// Module Type: producer
// File:        G4DSReader_module.cc
//
// Generated at Thu Dec  4 13:33:39 2014 by Alden Fan using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <string>
#include <iostream>
#include <fstream>

#include "darkart/Products/PeHit.hh"

#include "MCEventStructure.hh"

namespace darkart {
  namespace MC {
    class G4DSReader;
  }
}

////////////////////////////////////////////////////////////////////////
// 2014-12-04 AFan
//
// This is a modularization of the existing electronics MC.
// 
// Read G4DS file and produce vector of PeHits, just as PeHitMaker does.
// 
////////////////////////////////////////////////////////////////////////


class darkart::MC::G4DSReader : public art::EDProducer {
public:
  explicit G4DSReader(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  G4DSReader(G4DSReader const &) = delete;
  G4DSReader(G4DSReader &&) = delete;
  G4DSReader & operator = (G4DSReader const &) = delete;
  G4DSReader & operator = (G4DSReader &&) = delete;

  // Required functions.
  void beginJob() override;
  void produce(art::Event & e) override;


private:

  std::string g4ds_filename_;
  ifstream* bin_fstream_;

  int  MCPmtMap[38];
  
  HeaderStructure theHeader_;
  EventStructureDiskFormat theEvent_;

  std::vector<DepositStructure>       theDeposits_;
  std::vector<DaughterStructure>      theDaughters_;
  std::vector<UserStructure>          theUsers_;
  std::vector<PhotonStructure>        thePhotons_;
  std::vector<PhotoElectronStructure> thePhotoElectrons_;
  std::vector<PhotoElectronStructure> theVetoPhotoElectrons_;
  std::vector<PhotoElectronStructure> theMuPhotoElectrons_;

  bool readHeader(ifstream*);
  bool readEvent(ifstream*);
  DepositStructure readDeposit (ifstream*) ;
  DaughterStructure readDaughter (ifstream*) ;
  UserStructure readUser (ifstream*) ;
  PhotonStructure readPhoton (ifstream*) ;
  PhotoElectronStructure readPhotoElectron (ifstream*) ;
  PhotoElectronStructure readVetoPhotoElectron (ifstream*) ;
  PhotoElectronStructure readMuPhotoElectron (ifstream*) ;
};

using namespace darkart::MC;

G4DSReader::G4DSReader(fhicl::ParameterSet const & p)
  : g4ds_filename_(p.get<std::string>("g4ds_filename"))
{
  produces<MC::PeHitVec>();
}

bool G4DSReader::readHeader(ifstream* file)
{
  int event_size;
  int event_size2;
  file->read ((char *)(&event_size), sizeof (int));  
  file->read ((char *)(&theHeader_), sizeof( HeaderStructure)  );  
  file->read ((char *)(&event_size2), sizeof (int));
  if (!(*file)) return false;
  return true;
}

DepositStructure G4DSReader::readDeposit(ifstream *file) {
  DepositStructure theDeposit ;
  file->read ((char *)(&theDeposit), sizeof( DepositStructure) );  
  return theDeposit;
} 

DaughterStructure  G4DSReader::readDaughter(ifstream *file) {
  DaughterStructure theDaughter ;
  file->read ((char *)(&theDaughter), sizeof( DaughterStructure) );  
  return theDaughter;
} 

UserStructure  G4DSReader::readUser(ifstream *file) {
  UserStructure theUser ;
  file->read ((char *)(&theUser), sizeof( UserStructure) );  
  return theUser;
} 

PhotonStructure  G4DSReader::readPhoton(ifstream *file) {
  PhotonStructure thePhoton ;
  file->read ((char *)(&thePhoton), sizeof( PhotonStructure) );       
  return thePhoton;
} 

PhotoElectronStructure  G4DSReader::readPhotoElectron(ifstream *file) {
  PhotoElectronStructure thePhotoElectron ;
  file->read ((char *)(&thePhotoElectron), sizeof( PhotoElectronStructure) );       
  return thePhotoElectron;
}
 
PhotoElectronStructure  G4DSReader::readVetoPhotoElectron(ifstream *file) {
  PhotoElectronStructure theVetoPhotoElectron ;
  file->read ((char *)(&theVetoPhotoElectron), sizeof( PhotoElectronStructure) );       
  return theVetoPhotoElectron;
} 

PhotoElectronStructure  G4DSReader::readMuPhotoElectron(ifstream *file) {
  PhotoElectronStructure theMuPhotoElectron ;
  file->read ((char *)(&theMuPhotoElectron), sizeof( PhotoElectronStructure) );       
  return theMuPhotoElectron;
} 


//Read the event form the ifstream binary file
bool G4DSReader::readEvent (ifstream *file) {
  theDeposits_.clear();
  theDaughters_.clear();
  theUsers_.clear() ;
  thePhotons_.clear();
  thePhotoElectrons_.clear() ;
  theVetoPhotoElectrons_.clear() ;
  theMuPhotoElectrons_.clear() ;   

  if (!(*file)) return 0;
  
  int event_size;
  int event_size2;
  file->read ((char *)(&event_size), sizeof (int)); 
  file->read ((char *)(&theEvent_), sizeof( EventStructureDiskFormat)  ); 
  if (file->eof()) return 1;

  for(int i=0; i<theEvent_.NDaughters; i++) theDaughters_.push_back(readDaughter(file));
  for(int i=0; i<theEvent_.NDeposits; i++)  theDeposits_.push_back(readDeposit(file));
  for(int i=0; i<theEvent_.NUsers; i++)     theUsers_.push_back(readUser(file));
  for(int i=0; i<theEvent_.NPH; i++)        thePhotons_.push_back(readPhoton(file));
  for(int i=0; i<theEvent_.NPE; i++)        thePhotoElectrons_.push_back(readPhotoElectron(file));
  for(int i=0; i<theEvent_.VetoNPE; i++)    theVetoPhotoElectrons_.push_back(readMuPhotoElectron(file));
  for(int i=0; i<theEvent_.MuNPE; i++)      theMuPhotoElectrons_.push_back(readMuPhotoElectron(file));
  file->read ((char *)(&event_size2), sizeof (int));  
  if (file->eof()) return 1;
  if (event_size != event_size2) return 0;

  return 1;

}



void G4DSReader::beginJob()
{
  bin_fstream_ = new ifstream(g4ds_filename_.c_str(), std::ios::binary);
  readHeader(bin_fstream_);

  
  MCPmtMap[0]  =   30;
  MCPmtMap[1]  =   35;
  MCPmtMap[2]  =   29;
  MCPmtMap[3]  =   26;
  MCPmtMap[4]  =   25;
  MCPmtMap[5]  =   24;
  MCPmtMap[6]  =   31;
  MCPmtMap[7]  =   36;
  MCPmtMap[8]  =   27;
  MCPmtMap[9]  =   20;
  MCPmtMap[10] =   22;
  MCPmtMap[11] =   32;
  MCPmtMap[12] =   34;
  MCPmtMap[13] =   37;
  MCPmtMap[14] =   28;
  MCPmtMap[15] =   19;
  MCPmtMap[16] =   21;
  MCPmtMap[17] =   23; 
  MCPmtMap[18] =   33;
  MCPmtMap[19] =   11;
  MCPmtMap[20] =   12;	
  MCPmtMap[21] =   16;	
  MCPmtMap[22] =   10;
  MCPmtMap[23] =    7;	
  MCPmtMap[24] =    6;	
  MCPmtMap[25] =    5;	
  MCPmtMap[26] =   15;
  MCPmtMap[27] =   17;	
  MCPmtMap[28] =    8;	
  MCPmtMap[29] =    1;	
  MCPmtMap[30] =    3;	
  MCPmtMap[31] =   13;	
  MCPmtMap[32] =   14;	
  MCPmtMap[33] =   18;	
  MCPmtMap[34] =    9;	
  MCPmtMap[35] =    0;	
  MCPmtMap[36] =    2;	
  MCPmtMap[37] =    4;		
}


void G4DSReader::produce(art::Event & e)
{
  std::unique_ptr<MC::PeHitVec> peVec(new MC::PeHitVec);

  readEvent(bin_fstream_);
  
  for (auto const& g4dsPe : thePhotoElectrons_) {
    PeHit pe;
    pe.pmt = MCPmtMap[g4dsPe.PMT];
    pe.time = g4dsPe.Time;
    peVec->push_back(std::move(pe));
  }
  
  e.put(std::move(peVec));
}

DEFINE_ART_MODULE(G4DSReader)
