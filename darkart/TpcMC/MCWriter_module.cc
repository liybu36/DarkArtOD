////////////////////////////////////////////////////////////////////////
// Class:       MCWriter
// Module Type: producer
// File:        MCWriter_module.cc
//
// Generated at Sat Nov  1 17:08:20 2014 by Alden Fan using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Provenance/ProductID.h"

#include <memory>
#include <iostream>
#include <algorithm> 

#include "artdaq-core/Data/Fragment.hh"
#include "artdaq-core/Data/Fragments.hh"
#include "artdaq-core/Data/detail/RawFragmentHeader.hh"

#include "darksidecore/Data/Config.hh"
#include "darksidecore/Data/V172xFragment.hh"
#include "darksidecore/Data/V172xFragmentWriter.hh"
#include "darksidecore/Data/V1495Fragment.hh"

#include "darkart/Products/Waveform.hh"
#include "darkart/Products/Channel.hh"

#include "darkart/TpcReco/ByChannel.hh"

namespace darkart {
  namespace MC {
    class MCWriter;
  }
}

class darkart::MC::MCWriter : public art::EDProducer {
public:
  explicit MCWriter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MCWriter(MCWriter const &) = delete;
  MCWriter(MCWriter &&) = delete;
  MCWriter & operator = (MCWriter const &) = delete;
  MCWriter & operator = (MCWriter &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  art::InputTag _real_v1720_tag;
  art::InputTag _real_v1495_tag;
  art::InputTag _ch_tag;
  art::InputTag _mc_wfm_tag;

};


darkart::MC::MCWriter::MCWriter(fhicl::ParameterSet const & p)
  : _real_v1720_tag(p.get<std::string>("real_v1720_tag"))
  , _real_v1495_tag(p.get<std::string>("real_v1495_tag"))
  , _ch_tag(p.get<std::string>("ch_tag"))
  , _mc_wfm_tag(p.get<std::string>("mc_wfm_tag"))
{
  produces<artdaq::Fragments>("V1720");
  produces<artdaq::Fragments>("V1495");
}


void darkart::MC::MCWriter::produce(art::Event & e)
{
  auto const& real_v1720 = e.getValidHandle<artdaq::Fragments>(_real_v1720_tag);
  auto const& real_v1495 = e.getValidHandle<artdaq::Fragments>(_real_v1495_tag);
  art::Handle<darkart::ChannelVec> chVecHandle; e.getByLabel(_ch_tag, chVecHandle);
  darkart::ByChannel<darkart::Waveform> get_wfm(chVecHandle, e, _mc_wfm_tag);
  //auto const& mc_wfms    = e.getValidHandle<darkart::WaveformVec>(_mc_wfm_tag);

  artdaq::Fragments frags(*real_v1720);
  
  std::unique_ptr<artdaq::Fragments> fragVec(new artdaq::Fragments);
  std::unique_ptr<artdaq::Fragments> v1495(new artdaq::Fragments(*real_v1495));

  size_t frag_counter = 0;
  for (auto const& realFrag : *real_v1720) {
    std::unique_ptr<artdaq::Fragment> ptr(new artdaq::Fragment(realFrag));

    ds50::V172xFragmentWriter fw(*ptr);
    
    // overwrite the data part.

    size_t nchans_per_frag = 8;
    fw.resize(nchans_per_frag*get_wfm(0)->wave.size()); //size of fragment is 8*nsamps
    fw.setBoardID(realFrag.fragmentID());
    auto it = fw.dataBegin();
    for (size_t i=0; i<nchans_per_frag; ++i) {
      size_t ch = i+realFrag.fragmentID()*nchans_per_frag;
      if (ch >= chVecHandle->size()) continue;
      auto const& sig_wfm = get_wfm(ch); //Ptr
      auto const& wfm = *sig_wfm; //mc_wfms->at(idx);
      for (size_t samp=0; samp<wfm.wave.size(); ++samp) {
        *it = wfm.wave[samp];
        ++it;
      }

    }


    
    
    // Instantiate new fragment with overwritten data.
    artdaq::Fragment& frag = *ptr;
    frag.setFragmentID(realFrag.fragmentID());
    // overwrite the record_length and post_trigger parameters in fragement metadata
    auto & md = *(frag.metadata<ds50::V172xFragment::metadata>());
    md.sample_rate_MHz = get_wfm(0)->sample_rate;
    md.record_length = get_wfm(0)->wave.size();
    md.post_trigger = (int) ((1.-float(get_wfm(0)->trigger_index)/get_wfm(0)->wave.size())*100.+0.001); //percentage

    fragVec->push_back(std::move(frag));
    


    
    ++frag_counter;
  }

  
  e.put(std::move(fragVec), "V1720");
  e.put(std::move(v1495), "V1495");
}

DEFINE_ART_MODULE(darkart::MC::MCWriter)
